{
  "pack_to_json.py": "import os\nimport json\nfrom pathlib import Path\n\ndef scan_rust_project(project_path: str) -> dict:\n    \"\"\"Scan a Rust project and create a simple path:content mapping\"\"\"\n    project_path = Path(project_path)\n    files_dict = {}\n\n    for root, _, files in os.walk(project_path):\n        root_path = Path(root)\n        \n        # Skip target directory and other common excludes\n        if any(p in str(root_path) for p in ['target/', '.git/', 'node_modules/', '.idea/']):\n            continue\n\n        for file_name in files:\n            file_path = root_path / file_name\n            \n            # Get relative path from project root\n            rel_path = str(file_path.relative_to(project_path))\n            \n            # Skip certain files\n            if any(p in rel_path for p in ['.git/', '.idea/']):\n                continue\n\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    if content.strip():  # Only add non-empty files\n                        files_dict[rel_path] = content\n            except Exception as e:\n                print(f\"Warning: Could not read {rel_path}: {e}\")\n\n    return files_dict\n\ndef main():\n    import argparse\n    parser = argparse.ArgumentParser(description='Convert Rust project to simple JSON format')\n    parser.add_argument('project_path', help='Path to the Rust project')\n    parser.add_argument('--output', '-o', default='project.json', help='Output JSON file')\n    args = parser.parse_args()\n\n    try:\n        print(f\"Scanning project: {args.project_path}\")\n        files_dict = scan_rust_project(args.project_path)\n        \n        with open(args.output, 'w', encoding='utf-8') as f:\n            json.dump(files_dict, f, indent=2)\n        \n        print(f\"\\nProject exported to: {args.output}\")\n        print(f\"Total files: {len(files_dict)}\")\n        \n    except Exception as e:\n        print(f\"Error: {e}\")\n        return 1\n    \n    return 0\n\nif __name__ == \"__main__\":\n    exit(main())\n\n",
  "config.toml": "# Event Bus Configuration\n[event_bus]\ntype = \"zmq\"\nzmq_address = \"tcp://127.0.0.1:5555\"\n\n# Component Configurations\n[components]\n # Exchange configurations\n [components.exchanges.kraken]\n enabled = true\n api_url = \"wss://ws.kraken.com\"\n pairs = [\"XBT/USD\", \"ETH/USD\"]\n\n [components.exchanges.coinbase]\n enabled = true\n api_url = \"wss://ws-feed.exchange.coinbase.com\"\n pairs = [\"BTC-USD\", \"ETH-USD\"]\n\n # Strategy configurations\n [components.strategies.arbitrage]\n enabled = true\n params = {\n     arbitrage_threshold = 0.01,  # 1% minimum spread\n     min_profit = 100.0,         # Minimum profit in USD\n     max_position_size = 1.0,    # Maximum position size in BTC\n     execution_timeout = 5000    # milliseconds\n }\n\n [components.strategies.mean_reversion]\n enabled = false\n params = {\n     moving_average_period = 20,\n     entry_threshold = 2.0,\n     exit_threshold = 0.5,\n     position_size = 0.1,\n     stop_loss = 0.02\n }\n # Broker configuration\n [components.broker.interactive_broker]\n enabled = true\n host = \"localhost\"\n port = 7497\n client_id = 1\n account_id = \"\"  # Add your account ID here\n paper_trading = true\n max_retries = 3\n timeout = 5000  # milliseconds\n\n # Data transformation configurations\n [components.data_transformations.sma_filter]\n enabled = true\n source_topic = \"market.data\"\n destination_topic = \"market.data.sma\"\n params = {\n     period = 10,\n     min_samples = 10,\n     update_interval = 1000  # milliseconds\n }\n\n [components.data_transformations.threshold_filter]\n enabled = true\n source_topic = \"market.data.sma\"\n destination_topic = \"market.data.signals\"\n params = {\n     threshold = 0.01,\n     direction = \"both\",  # \"positive\", \"negative\", or \"both\"\n     window_size = 5\n }\n # UI configuration\n [components.ui]\n enabled = true\n host = \"127.0.0.1\"\n port = 8080\n topics = [\"market.data\", \"market.signals\", \"orders\", \"trades\", \"metrics\", \"audit\"]\n refresh_interval = 1000  # milliseconds\n\n # Logging configuration\n [components.logging]\n enabled = true\n level = \"info\"  # debug, info, warn, error\n file = \"trading_platform.log\"\n topics = [\"market.data\", \"market.signals\", \"orders\", \"trades\", \"metrics\", \"audit\"]\n\n # Metrics configuration\n [components.metrics]\n enabled = true\n host = \"127.0.0.1\"\n port = 9090\n topics = [\"market.data\", \"orders\", \"trades\", \"performance\"]\n\n # Audit configuration\n [components.audit]\n enabled = true\n storage_path = \"./audit_logs\"\n retention_days = 30\n topics = [\"orders\", \"trades\", \"account\", \"system\"]\n\n # Persistence configuration\n [persistence]\n type = \"postgres\"  # memory, postgres, mongodb\n postgres = {\n     host = \"localhost\",\n     port = 5432,\n     database = \"trading_platform\",\n     username = \"trading_user\",\n     password = \"\",  # Add your database password here\n     max_connections = 5\n }\n\n # Security configuration\n [security]\n type = \"jwt\"  # basic, jwt\n jwt_secret = \"\"  # Add your JWT secret here\n token_expiry = 3600  # seconds\n users = [\n     { username = \"admin\", password = \"\", role = \"admin\" },  # Add hashed password here\n     { username = \"trader\", password = \"\", role = \"trader\" }  # Add hashed password here\n ]\n\n # Rate limiting\n [security.rate_limit]\n enabled = true\n requests_per_minute = 60\n burst = 10\n",
  "fix_files.py": "#!/usr/bin/env python3\nimport os\nimport shutil\nfrom pathlib import Path\n\ndef create_directory(path):\n    \"\"\"Create directory if it doesn't exist\"\"\"\n    Path(path).mkdir(parents=True, exist_ok=True)\n\ndef write_file(path, content):\n    \"\"\"Write content to file, creating parent directories if needed\"\"\"\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(content)\n\ndef main():\n    # Base project directory (assuming script is run from project root)\n    src_dir = \"src\"\n    base_dir = Path(src_dir)\n\n    # Create main module directories\n    module_dirs = [\n        \"common\",\n        \"domain\",\n        \"infra\",\n        \"ui\",\n    ]\n\n    for dir_name in module_dirs:\n        create_directory(base_dir / dir_name)\n\n    # Create subdirectories\n    subdirs = [\n        \"infra/event_bus\",\n        \"infra/adapters\",\n        \"infra/broker_adapters\",\n        \"infra/execution\",\n        \"domain/strategies\",\n    ]\n\n    for subdir in subdirs:\n        create_directory(base_dir / subdir)\n\n    # Define mod.rs files content\n    mod_files = {\n        \"common/mod.rs\": \"\"\"pub mod types;\npub mod enums;\npub mod constants;\npub mod utils;\n\"\"\",\n        \"domain/mod.rs\": \"\"\"pub mod events;\npub mod interfaces;\npub mod models;\npub mod strategies;\n\"\"\",\n        \"infra/mod.rs\": \"\"\"pub mod adapters;\npub mod broker_adapters;\npub mod event_bus;\npub mod execution;\n\"\"\",\n        \"ui/mod.rs\": \"\"\"pub mod console;\npub mod logger;\npub mod metrics;\npub mod audit;\n\"\"\",\n        \"domain/strategies/mod.rs\": \"\"\"pub mod arbitrage;\npub mod mean_reversion;\npub mod base;\n\"\"\",\n        \"infra/adapters/mod.rs\": \"\"\"pub mod kraken;\npub mod coinbase;\npub mod exchange;\n\"\"\",\n        \"infra/broker_adapters/mod.rs\": \"\"\"pub mod interactive_broker_adapter;\npub mod base;\n\"\"\",\n        \"infra/event_bus/mod.rs\": \"pub mod zmq;\\n\",\n        \"infra/execution/mod.rs\": \"pub mod manager;\\n\",\n    }\n\n    # Write mod.rs files\n    print(\"Creating module files...\")\n    for file_path, content in mod_files.items():\n        write_file(base_dir / file_path, content)\n        print(f\"Created {file_path}\")\n\n    # Move existing files to their new locations (if they exist)\n    file_moves = [\n        (\"common.rs\", \"common/types.rs\"),  # Split common.rs content appropriately\n        (\"lib.rs\", \"lib.rs\"),  # Keep in root\n        (\"main.rs\", \"main.rs\"),  # Keep in root\n        (\"config.rs\", \"config.rs\"),  # Keep in root\n        (\"domain/events.rs\", \"domain/events.rs\"),\n        (\"domain/interfaces.rs\", \"domain/interfaces.rs\"),\n        (\"domain/models.rs\", \"domain/models.rs\"),\n        (\"domain/strategies/arbitrage.rs\", \"domain/strategies/arbitrage.rs\"),\n        (\"domain/strategies/mean_reversion.rs\", \"domain/strategies/mean_reversion.rs\"),\n        (\"domain/strategies/base.rs\", \"domain/strategies/base.rs\"),\n        (\"infra/event_bus/zmq.rs\", \"infra/event_bus/zmq.rs\"),\n        (\"infra/adapters/kraken.rs\", \"infra/adapters/kraken.rs\"),\n        (\"infra/adapters/coinbase.rs\", \"infra/adapters/coinbase.rs\"),\n        (\"infra/adapters/exchange.rs\", \"infra/adapters/exchange.rs\"),\n        (\"infra/broker_adapters/interactive_broker_adapter.rs\", \n         \"infra/broker_adapters/interactive_broker_adapter.rs\"),\n        (\"infra/broker_adapters/base.rs\", \"infra/broker_adapters/base.rs\"),\n        (\"infra/execution/manager.rs\", \"infra/execution/manager.rs\"),\n        (\"ui/console.rs\", \"ui/console.rs\"),\n        (\"ui/logger.rs\", \"ui/logger.rs\"),\n        (\"ui/metrics.rs\", \"ui/metrics.rs\"),\n        (\"ui/audit.rs\", \"ui/audit.rs\"),\n    ]\n\n    print(\"\\nMoving files to their new locations...\")\n    for src, dst in file_moves:\n        src_path = base_dir / src\n        dst_path = base_dir / dst\n        try:\n            if src_path.exists():\n                print(f\"Moving {src} to {dst}\")\n                dst_path.parent.mkdir(parents=True, exist_ok=True)\n                shutil.move(str(src_path), str(dst_path))\n            else:\n                print(f\"Source file {src} not found, skipping...\")\n        except Exception as e:\n            print(f\"Error moving {src} to {dst}: {e}\")\n\n    # Create directories and empty files for any missing required files\n    required_files = [\n        \"common/utils.rs\",\n        \"common/constants.rs\",\n        \"common/enums.rs\",\n    ]\n\n    print(\"\\nCreating empty files for missing required modules...\")\n    for file_path in required_files:\n        full_path = base_dir / file_path\n        if not full_path.exists():\n            print(f\"Creating empty file {file_path}\")\n            write_file(full_path, \"// Add content here\\n\")\n\n    print(\"\\nModule structure has been organized. Please verify the changes.\")\n    print(\"Note: You may need to manually split common.rs into separate files under the common directory.\")\n    print(\"\\nNext steps:\")\n    print(\"1. Verify all files are in the correct locations\")\n    print(\"2. Split common.rs content into types.rs, enums.rs, constants.rs, and utils.rs\")\n    print(\"3. Update import paths in your code if necessary\")\n\nif __name__ == \"__main__\":\n    main()\n",
  "Cargo.toml": "[package]\nname = \"trading_platform\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\ntokio = { version = \"1\", features = [\"full\"] }\nzmq = \"0.10\"\nconfig = \"0.13\"\nlog = \"0.4\"\nenv_logger = \"0.10\"\nthiserror = \"1.0\"\nasync-trait = \"0.1.77\"\nanyhow = \"1.0\"\nuuid = { version = \"1.6.1\", features = [\"v4\"] }\nfutures = \"0.3\"\nrust_decimal = { version = \"1.34\", features = [\"serde-float\"] }\ntokio-websockets = \"0.1\"\ntokio-tungstenite = { version = \"0.20\", features = [\"native-tls\"] }\nurl = \"2.5\"\nfutures-util = \"0.3\"\n",
  "Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"addr2line\"\nversion = \"0.24.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1\"\ndependencies = [\n \"gimli\",\n]\n\n[[package]]\nname = \"adler2\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627\"\n\n[[package]]\nname = \"ahash\"\nversion = \"0.7.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"891477e0c6a8957309ee5c45a6368af3ae14bb510732d2684ffa19af310920f9\"\ndependencies = [\n \"getrandom\",\n \"once_cell\",\n \"version_check\",\n]\n\n[[package]]\nname = \"aho-corasick\"\nversion = \"1.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"anyhow\"\nversion = \"1.0.95\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34ac096ce696dc2fcabef30516bb13c0a68a11d30131d3df6f04711467681b04\"\n\n[[package]]\nname = \"arrayvec\"\nversion = \"0.7.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50\"\n\n[[package]]\nname = \"async-trait\"\nversion = \"0.1.83\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"721cae7de5c34fbb2acd27e21e6d2cf7b886dce0c27388d46c4e6c47ea4318dd\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26\"\n\n[[package]]\nname = \"backtrace\"\nversion = \"0.3.74\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a\"\ndependencies = [\n \"addr2line\",\n \"cfg-if\",\n \"libc\",\n \"miniz_oxide\",\n \"object\",\n \"rustc-demangle\",\n \"windows-targets\",\n]\n\n[[package]]\nname = \"base64\"\nversion = \"0.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"2.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de\"\n\n[[package]]\nname = \"bitvec\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c\"\ndependencies = [\n \"funty\",\n \"radium\",\n \"tap\",\n \"wyz\",\n]\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"borsh\"\nversion = \"1.5.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2506947f73ad44e344215ccd6403ac2ae18cd8e046e581a441bf8d199f257f03\"\ndependencies = [\n \"borsh-derive\",\n \"cfg_aliases\",\n]\n\n[[package]]\nname = \"borsh-derive\"\nversion = \"1.5.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c2593a3b8b938bd68373196c9832f516be11fa487ef4ae745eb282e6a56a7244\"\ndependencies = [\n \"once_cell\",\n \"proc-macro-crate\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"bytecheck\"\nversion = \"0.6.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"23cdc57ce23ac53c931e88a43d06d070a6fd142f2617be5855eb75efc9beb1c2\"\ndependencies = [\n \"bytecheck_derive\",\n \"ptr_meta\",\n \"simdutf8\",\n]\n\n[[package]]\nname = \"bytecheck_derive\"\nversion = \"0.6.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3db406d29fbcd95542e92559bed4d8ad92636d1ca8b3b72ede10b4bcc010e659\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b\"\n\n[[package]]\nname = \"bytes\"\nversion = \"1.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"325918d6fe32f23b19878fe4b34794ae41fc19ddbe53b10571a4874d44ffd39b\"\n\n[[package]]\nname = \"cc\"\nversion = \"1.2.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8d6dbb628b8f8555f86d0323c2eb39e3ec81901f4b83e091db8a6a76d316a333\"\ndependencies = [\n \"jobserver\",\n \"libc\",\n \"shlex\",\n]\n\n[[package]]\nname = \"cfg-expr\"\nversion = \"0.15.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d067ad48b8650848b989a59a86c6c36a995d02d2bf778d45c3c5d57bc2718f02\"\ndependencies = [\n \"smallvec\",\n \"target-lexicon\",\n]\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"cfg_aliases\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724\"\n\n[[package]]\nname = \"config\"\nversion = \"0.13.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"23738e11972c7643e4ec947840fc463b6a571afcd3e735bdfce7d03c7a784aca\"\ndependencies = [\n \"async-trait\",\n \"json5\",\n \"lazy_static\",\n \"nom\",\n \"pathdiff\",\n \"ron\",\n \"rust-ini\",\n \"serde\",\n \"serde_json\",\n \"toml 0.5.11\",\n \"yaml-rust\",\n]\n\n[[package]]\nname = \"core-foundation\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f\"\ndependencies = [\n \"core-foundation-sys\",\n \"libc\",\n]\n\n[[package]]\nname = \"core-foundation-sys\"\nversion = \"0.8.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b\"\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"16b80225097f2e5ae4e7179dd2266824648f3e2f49d9134d584b76389d31c4c3\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"crossbeam\"\nversion = \"0.8.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1137cd7e7fc0fb5d3c5a8678be38ec56e819125d8d7907411fe24ccb943faca8\"\ndependencies = [\n \"crossbeam-channel\",\n \"crossbeam-deque\",\n \"crossbeam-epoch\",\n \"crossbeam-queue\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-channel\"\nversion = \"0.5.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"06ba6d68e24814cb8de6bb986db8222d3a027d15872cabc0d18817bc3c0e4471\"\ndependencies = [\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-deque\"\nversion = \"0.8.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51\"\ndependencies = [\n \"crossbeam-epoch\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-epoch\"\nversion = \"0.9.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e\"\ndependencies = [\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-queue\"\nversion = \"0.3.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0f58bbc28f91df819d0aa2a2c00cd19754769c2fad90579b3592b1c9ba7a3115\"\ndependencies = [\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"crossbeam-utils\"\nversion = \"0.8.21\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28\"\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"typenum\",\n]\n\n[[package]]\nname = \"data-encoding\"\nversion = \"2.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e8566979429cf69b49a5c740c60791108e86440e8be149bbea4fe54d2c32d6e2\"\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n]\n\n[[package]]\nname = \"dircpy\"\nversion = \"0.3.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a88521b0517f5f9d51d11925d8ab4523497dcf947073fa3231a311b63941131c\"\ndependencies = [\n \"jwalk\",\n \"log\",\n \"walkdir\",\n]\n\n[[package]]\nname = \"displaydoc\"\nversion = \"0.2.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"dlv-list\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0688c2a7f92e427f44895cd63841bff7b29f8d7a1648b9e7e07a4a365b2e1257\"\n\n[[package]]\nname = \"either\"\nversion = \"1.13.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0\"\n\n[[package]]\nname = \"env_logger\"\nversion = \"0.10.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580\"\ndependencies = [\n \"humantime\",\n \"is-terminal\",\n \"log\",\n \"regex\",\n \"termcolor\",\n]\n\n[[package]]\nname = \"equivalent\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5\"\n\n[[package]]\nname = \"errno\"\nversion = \"0.3.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d\"\ndependencies = [\n \"libc\",\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"fastrand\"\nversion = \"1.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be\"\ndependencies = [\n \"instant\",\n]\n\n[[package]]\nname = \"fastrand\"\nversion = \"2.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be\"\n\n[[package]]\nname = \"fnv\"\nversion = \"1.0.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n\n[[package]]\nname = \"foreign-types\"\nversion = \"0.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1\"\ndependencies = [\n \"foreign-types-shared\",\n]\n\n[[package]]\nname = \"foreign-types-shared\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b\"\n\n[[package]]\nname = \"form_urlencoded\"\nversion = \"1.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456\"\ndependencies = [\n \"percent-encoding\",\n]\n\n[[package]]\nname = \"funty\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c\"\n\n[[package]]\nname = \"futures\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876\"\ndependencies = [\n \"futures-channel\",\n \"futures-core\",\n \"futures-executor\",\n \"futures-io\",\n \"futures-sink\",\n \"futures-task\",\n \"futures-util\",\n]\n\n[[package]]\nname = \"futures-channel\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10\"\ndependencies = [\n \"futures-core\",\n \"futures-sink\",\n]\n\n[[package]]\nname = \"futures-core\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e\"\n\n[[package]]\nname = \"futures-executor\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f\"\ndependencies = [\n \"futures-core\",\n \"futures-task\",\n \"futures-util\",\n]\n\n[[package]]\nname = \"futures-io\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6\"\n\n[[package]]\nname = \"futures-macro\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"futures-sink\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7\"\n\n[[package]]\nname = \"futures-task\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988\"\n\n[[package]]\nname = \"futures-util\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81\"\ndependencies = [\n \"futures-channel\",\n \"futures-core\",\n \"futures-io\",\n \"futures-macro\",\n \"futures-sink\",\n \"futures-task\",\n \"memchr\",\n \"pin-project-lite\",\n \"pin-utils\",\n \"slab\",\n]\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"gimli\"\nversion = \"0.31.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f\"\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\ndependencies = [\n \"ahash\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.15.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289\"\n\n[[package]]\nname = \"heck\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea\"\n\n[[package]]\nname = \"hermit-abi\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc\"\n\n[[package]]\nname = \"http\"\nversion = \"0.2.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1\"\ndependencies = [\n \"bytes\",\n \"fnv\",\n \"itoa\",\n]\n\n[[package]]\nname = \"httparse\"\nversion = \"1.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7d71d3574edd2771538b901e6549113b4006ece66150fb69c0fb6d9a2adae946\"\n\n[[package]]\nname = \"humantime\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n\n[[package]]\nname = \"icu_collections\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"db2fa452206ebee18c4b5c2274dbf1de17008e874b4dc4f0aea9d01ca79e4526\"\ndependencies = [\n \"displaydoc\",\n \"yoke\",\n \"zerofrom\",\n \"zerovec\",\n]\n\n[[package]]\nname = \"icu_locid\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"13acbb8371917fc971be86fc8057c41a64b521c184808a698c02acc242dbf637\"\ndependencies = [\n \"displaydoc\",\n \"litemap\",\n \"tinystr\",\n \"writeable\",\n \"zerovec\",\n]\n\n[[package]]\nname = \"icu_locid_transform\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"01d11ac35de8e40fdeda00d9e1e9d92525f3f9d887cdd7aa81d727596788b54e\"\ndependencies = [\n \"displaydoc\",\n \"icu_locid\",\n \"icu_locid_transform_data\",\n \"icu_provider\",\n \"tinystr\",\n \"zerovec\",\n]\n\n[[package]]\nname = \"icu_locid_transform_data\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fdc8ff3388f852bede6b579ad4e978ab004f139284d7b28715f773507b946f6e\"\n\n[[package]]\nname = \"icu_normalizer\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"19ce3e0da2ec68599d193c93d088142efd7f9c5d6fc9b803774855747dc6a84f\"\ndependencies = [\n \"displaydoc\",\n \"icu_collections\",\n \"icu_normalizer_data\",\n \"icu_properties\",\n \"icu_provider\",\n \"smallvec\",\n \"utf16_iter\",\n \"utf8_iter\",\n \"write16\",\n \"zerovec\",\n]\n\n[[package]]\nname = \"icu_normalizer_data\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f8cafbf7aa791e9b22bec55a167906f9e1215fd475cd22adfcf660e03e989516\"\n\n[[package]]\nname = \"icu_properties\"\nversion = \"1.5.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"93d6020766cfc6302c15dbbc9c8778c37e62c14427cb7f6e601d849e092aeef5\"\ndependencies = [\n \"displaydoc\",\n \"icu_collections\",\n \"icu_locid_transform\",\n \"icu_properties_data\",\n \"icu_provider\",\n \"tinystr\",\n \"zerovec\",\n]\n\n[[package]]\nname = \"icu_properties_data\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"67a8effbc3dd3e4ba1afa8ad918d5684b8868b3b26500753effea8d2eed19569\"\n\n[[package]]\nname = \"icu_provider\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6ed421c8a8ef78d3e2dbc98a973be2f3770cb42b606e3ab18d6237c4dfde68d9\"\ndependencies = [\n \"displaydoc\",\n \"icu_locid\",\n \"icu_provider_macros\",\n \"stable_deref_trait\",\n \"tinystr\",\n \"writeable\",\n \"yoke\",\n \"zerofrom\",\n \"zerovec\",\n]\n\n[[package]]\nname = \"icu_provider_macros\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1ec89e9337638ecdc08744df490b221a7399bf8d164eb52a665454e60e075ad6\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"idna\"\nversion = \"1.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e\"\ndependencies = [\n \"idna_adapter\",\n \"smallvec\",\n \"utf8_iter\",\n]\n\n[[package]]\nname = \"idna_adapter\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"daca1df1c957320b2cf139ac61e7bd64fed304c5040df000a745aa1de3b4ef71\"\ndependencies = [\n \"icu_normalizer\",\n \"icu_properties\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"2.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62f822373a4fe84d4bb149bf54e584a7f4abec90e072ed49cda0edea5b95471f\"\ndependencies = [\n \"equivalent\",\n \"hashbrown 0.15.2\",\n]\n\n[[package]]\nname = \"instant\"\nversion = \"0.1.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"is-terminal\"\nversion = \"0.4.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b\"\ndependencies = [\n \"hermit-abi\",\n \"libc\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d75a2a4b1b190afb6f5425f10f6a8f959d2ea0b9c2b1d79553551850539e4674\"\n\n[[package]]\nname = \"jobserver\"\nversion = \"0.1.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"48d1dbcbbeb6a7fec7e059840aa538bd62aaccf972c7346c4d9d2059312853d0\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"json5\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"96b0db21af676c1ce64250b5f40f3ce2cf27e4e47cb91ed91eb6fe9350b430c1\"\ndependencies = [\n \"pest\",\n \"pest_derive\",\n \"serde\",\n]\n\n[[package]]\nname = \"jwalk\"\nversion = \"0.8.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2735847566356cd2179a2a38264839308f7079fa96e6bd5a42d740460e003c56\"\ndependencies = [\n \"crossbeam\",\n \"rayon\",\n]\n\n[[package]]\nname = \"lazy_static\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.169\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b5aba8db14291edd000dfcc4d620c7ebfb122c613afb886ca8803fa4e128a20a\"\n\n[[package]]\nname = \"linked-hash-map\"\nversion = \"0.5.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f\"\n\n[[package]]\nname = \"linux-raw-sys\"\nversion = \"0.4.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89\"\n\n[[package]]\nname = \"litemap\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4ee93343901ab17bd981295f2cf0026d4ad018c7c31ba84549a4ddbb47a45104\"\n\n[[package]]\nname = \"lock_api\"\nversion = \"0.4.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17\"\ndependencies = [\n \"autocfg\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"log\"\nversion = \"0.4.22\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24\"\n\n[[package]]\nname = \"memchr\"\nversion = \"2.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3\"\n\n[[package]]\nname = \"minimal-lexical\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a\"\n\n[[package]]\nname = \"miniz_oxide\"\nversion = \"0.8.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4ffbe83022cedc1d264172192511ae958937694cd57ce297164951b8b3568394\"\ndependencies = [\n \"adler2\",\n]\n\n[[package]]\nname = \"mio\"\nversion = \"1.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2886843bf800fba2e3377cff24abf6379b4c4d5c6681eaf9ea5b0d15090450bd\"\ndependencies = [\n \"libc\",\n \"wasi\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"native-tls\"\nversion = \"0.2.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466\"\ndependencies = [\n \"libc\",\n \"log\",\n \"openssl\",\n \"openssl-probe\",\n \"openssl-sys\",\n \"schannel\",\n \"security-framework\",\n \"security-framework-sys\",\n \"tempfile\",\n]\n\n[[package]]\nname = \"nom\"\nversion = \"7.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a\"\ndependencies = [\n \"memchr\",\n \"minimal-lexical\",\n]\n\n[[package]]\nname = \"num-traits\"\nversion = \"0.2.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"object\"\nversion = \"0.36.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"once_cell\"\nversion = \"1.20.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1261fe7e33c73b354eab43b1273a57c8f967d0391e80353e51f764ac02cf6775\"\n\n[[package]]\nname = \"openssl\"\nversion = \"0.10.68\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6174bc48f102d208783c2c84bf931bb75927a617866870de8a4ea85597f871f5\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"cfg-if\",\n \"foreign-types\",\n \"libc\",\n \"once_cell\",\n \"openssl-macros\",\n \"openssl-sys\",\n]\n\n[[package]]\nname = \"openssl-macros\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"openssl-probe\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf\"\n\n[[package]]\nname = \"openssl-sys\"\nversion = \"0.9.104\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"45abf306cbf99debc8195b66b7346498d7b10c210de50418b5ccd7ceba08c741\"\ndependencies = [\n \"cc\",\n \"libc\",\n \"pkg-config\",\n \"vcpkg\",\n]\n\n[[package]]\nname = \"ordered-multimap\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ccd746e37177e1711c20dd619a1620f34f5c8b569c53590a72dedd5344d8924a\"\ndependencies = [\n \"dlv-list\",\n \"hashbrown 0.12.3\",\n]\n\n[[package]]\nname = \"parking_lot\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27\"\ndependencies = [\n \"lock_api\",\n \"parking_lot_core\",\n]\n\n[[package]]\nname = \"parking_lot_core\"\nversion = \"0.9.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"redox_syscall\",\n \"smallvec\",\n \"windows-targets\",\n]\n\n[[package]]\nname = \"pathdiff\"\nversion = \"0.2.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"df94ce210e5bc13cb6651479fa48d14f601d9858cfe0467f43ae157023b938d3\"\n\n[[package]]\nname = \"percent-encoding\"\nversion = \"2.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e\"\n\n[[package]]\nname = \"pest\"\nversion = \"2.7.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8b7cafe60d6cf8e62e1b9b2ea516a089c008945bb5a275416789e7db0bc199dc\"\ndependencies = [\n \"memchr\",\n \"thiserror 2.0.9\",\n \"ucd-trie\",\n]\n\n[[package]]\nname = \"pest_derive\"\nversion = \"2.7.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"816518421cfc6887a0d62bf441b6ffb4536fcc926395a69e1a85852d4363f57e\"\ndependencies = [\n \"pest\",\n \"pest_generator\",\n]\n\n[[package]]\nname = \"pest_generator\"\nversion = \"2.7.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7d1396fd3a870fc7838768d171b4616d5c91f6cc25e377b673d714567d99377b\"\ndependencies = [\n \"pest\",\n \"pest_meta\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"pest_meta\"\nversion = \"2.7.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e1e58089ea25d717bfd31fb534e4f3afcc2cc569c70de3e239778991ea3b7dea\"\ndependencies = [\n \"once_cell\",\n \"pest\",\n \"sha2\",\n]\n\n[[package]]\nname = \"pin-project-lite\"\nversion = \"0.2.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"915a1e146535de9163f3987b8944ed8cf49a18bb0056bcebcdcece385cece4ff\"\n\n[[package]]\nname = \"pin-utils\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184\"\n\n[[package]]\nname = \"pkg-config\"\nversion = \"0.3.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"953ec861398dccce10c670dfeaf3ec4911ca479e9c02154b3a215178c5f566f2\"\n\n[[package]]\nname = \"ppv-lite86\"\nversion = \"0.2.20\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04\"\ndependencies = [\n \"zerocopy\",\n]\n\n[[package]]\nname = \"proc-macro-crate\"\nversion = \"3.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8ecf48c7ca261d60b74ab1a7b20da18bede46776b2e55535cb958eb595c5fa7b\"\ndependencies = [\n \"toml_edit\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.92\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"37d3544b3f2748c54e147655edb5025752e2303145b5aefb3c3ea2c78b973bb0\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"ptr_meta\"\nversion = \"0.1.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0738ccf7ea06b608c10564b31debd4f5bc5e197fc8bfe088f68ae5ce81e7a4f1\"\ndependencies = [\n \"ptr_meta_derive\",\n]\n\n[[package]]\nname = \"ptr_meta_derive\"\nversion = \"0.1.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"16b845dbfca988fa33db069c0e230574d15a3088f147a87b64c7589eb662c9ac\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.38\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0e4dccaaaf89514f546c693ddc140f729f958c247918a13380cccc6078391acc\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"radium\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09\"\n\n[[package]]\nname = \"rand\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\ndependencies = [\n \"libc\",\n \"rand_chacha\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_chacha\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\ndependencies = [\n \"ppv-lite86\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_core\"\nversion = \"0.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"rayon\"\nversion = \"1.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa\"\ndependencies = [\n \"either\",\n \"rayon-core\",\n]\n\n[[package]]\nname = \"rayon-core\"\nversion = \"1.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2\"\ndependencies = [\n \"crossbeam-deque\",\n \"crossbeam-utils\",\n]\n\n[[package]]\nname = \"redox_syscall\"\nversion = \"0.5.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"03a862b389f93e68874fbf580b9de08dd02facb9a788ebadaf4a3fd33cf58834\"\ndependencies = [\n \"bitflags 2.6.0\",\n]\n\n[[package]]\nname = \"regex\"\nversion = \"1.11.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-automata\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-automata\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c\"\n\n[[package]]\nname = \"rend\"\nversion = \"0.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"71fe3824f5629716b1589be05dacd749f6aa084c87e00e016714a8cdfccc997c\"\ndependencies = [\n \"bytecheck\",\n]\n\n[[package]]\nname = \"rkyv\"\nversion = \"0.7.45\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9008cd6385b9e161d8229e1f6549dd23c3d022f132a2ea37ac3a10ac4935779b\"\ndependencies = [\n \"bitvec\",\n \"bytecheck\",\n \"bytes\",\n \"hashbrown 0.12.3\",\n \"ptr_meta\",\n \"rend\",\n \"rkyv_derive\",\n \"seahash\",\n \"tinyvec\",\n \"uuid\",\n]\n\n[[package]]\nname = \"rkyv_derive\"\nversion = \"0.7.45\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"503d1d27590a2b0a3a4ca4c94755aa2875657196ecbf401a42eff41d7de532c0\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"ron\"\nversion = \"0.7.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"88073939a61e5b7680558e6be56b419e208420c2adb92be54921fa6b72283f1a\"\ndependencies = [\n \"base64\",\n \"bitflags 1.3.2\",\n \"serde\",\n]\n\n[[package]]\nname = \"rust-ini\"\nversion = \"0.18.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f6d5f2436026b4f6e79dc829837d467cc7e9a55ee40e750d716713540715a2df\"\ndependencies = [\n \"cfg-if\",\n \"ordered-multimap\",\n]\n\n[[package]]\nname = \"rust_decimal\"\nversion = \"1.36.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b082d80e3e3cc52b2ed634388d436fe1f4de6af5786cc2de9ba9737527bdf555\"\ndependencies = [\n \"arrayvec\",\n \"borsh\",\n \"bytes\",\n \"num-traits\",\n \"rand\",\n \"rkyv\",\n \"serde\",\n \"serde_json\",\n]\n\n[[package]]\nname = \"rustc-demangle\"\nversion = \"0.1.24\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f\"\n\n[[package]]\nname = \"rustix\"\nversion = \"0.38.42\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f93dc38ecbab2eb790ff964bb77fa94faf256fd3e73285fd7ba0903b76bedb85\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"errno\",\n \"libc\",\n \"linux-raw-sys\",\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f\"\n\n[[package]]\nname = \"same-file\"\nversion = \"1.0.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502\"\ndependencies = [\n \"winapi-util\",\n]\n\n[[package]]\nname = \"schannel\"\nversion = \"0.1.27\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1f29ebaa345f945cec9fbbc532eb307f0fdad8161f281b6369539c8d84876b3d\"\ndependencies = [\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"scopeguard\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49\"\n\n[[package]]\nname = \"seahash\"\nversion = \"4.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1c107b6f4780854c8b126e228ea8869f4d7b71260f962fefb57b996b8959ba6b\"\n\n[[package]]\nname = \"security-framework\"\nversion = \"2.11.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02\"\ndependencies = [\n \"bitflags 2.6.0\",\n \"core-foundation\",\n \"core-foundation-sys\",\n \"libc\",\n \"security-framework-sys\",\n]\n\n[[package]]\nname = \"security-framework-sys\"\nversion = \"2.13.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1863fd3768cd83c56a7f60faa4dc0d403f1b6df0a38c3c25f44b7894e45370d5\"\ndependencies = [\n \"core-foundation-sys\",\n \"libc\",\n]\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.217\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"02fc4265df13d6fa1d00ecff087228cc0a2b5f3c0e87e258d8b94a156e984c70\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.217\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a9bf7cf98d04a2b28aead066b7496853d4779c9cc183c440dbac457641e19a0\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.134\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d00f4175c42ee48b15416f6193a959ba3a0d67fc699a0db9ad12df9f83991c7d\"\ndependencies = [\n \"itoa\",\n \"memchr\",\n \"ryu\",\n \"serde\",\n]\n\n[[package]]\nname = \"serde_spanned\"\nversion = \"0.6.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"87607cb1398ed59d48732e575a4c28a7a8ebf2454b964fe3f224f2afc07909e1\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"sha1\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"sha1_smol\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbfa15b3dddfee50a0fff136974b3e1bde555604ba463834a7eb7deb6417705d\"\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"shlex\"\nversion = \"1.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64\"\n\n[[package]]\nname = \"signal-hook-registry\"\nversion = \"1.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"simdutf8\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3a9fe34e3e7a50316060351f37187a3f546bce95496156754b601a5fa71b76e\"\n\n[[package]]\nname = \"slab\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"smallvec\"\nversion = \"1.13.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n\n[[package]]\nname = \"socket2\"\nversion = \"0.5.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c970269d99b64e60ec3bd6ad27270092a5394c4e309314b18ae3fe575695fbe8\"\ndependencies = [\n \"libc\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"stable_deref_trait\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.109\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.92\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"70ae51629bf965c5c098cc9e87908a3df5301051a9e087d6f9bef5c9771ed126\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"synstructure\"\nversion = \"0.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c8af7666ab7b6390ab78131fb5b0fce11d6b7a6951602017c35fa82800708971\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"system-deps\"\nversion = \"6.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a3e535eb8dded36d55ec13eddacd30dec501792ff23a0b1682c38601b8cf2349\"\ndependencies = [\n \"cfg-expr\",\n \"heck\",\n \"pkg-config\",\n \"toml 0.8.19\",\n \"version-compare\",\n]\n\n[[package]]\nname = \"tap\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n\n[[package]]\nname = \"target-lexicon\"\nversion = \"0.12.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1\"\n\n[[package]]\nname = \"tempfile\"\nversion = \"3.14.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"28cce251fcbc87fac86a866eeb0d6c2d536fc16d06f184bb61aeae11aa4cee0c\"\ndependencies = [\n \"cfg-if\",\n \"fastrand 2.3.0\",\n \"once_cell\",\n \"rustix\",\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"termcolor\"\nversion = \"1.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755\"\ndependencies = [\n \"winapi-util\",\n]\n\n[[package]]\nname = \"thiserror\"\nversion = \"1.0.69\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52\"\ndependencies = [\n \"thiserror-impl 1.0.69\",\n]\n\n[[package]]\nname = \"thiserror\"\nversion = \"2.0.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f072643fd0190df67a8bab670c20ef5d8737177d6ac6b2e9a236cb096206b2cc\"\ndependencies = [\n \"thiserror-impl 2.0.9\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"1.0.69\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"2.0.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7b50fa271071aae2e6ee85f842e2e28ba8cd2c5fb67f11fcb1fd70b276f9e7d4\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"tinystr\"\nversion = \"0.7.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9117f5d4db391c1cf6927e7bea3db74b9a1c1add8f7eda9ffd5364f40f57b82f\"\ndependencies = [\n \"displaydoc\",\n \"zerovec\",\n]\n\n[[package]]\nname = \"tinyvec\"\nversion = \"1.8.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"022db8904dfa342efe721985167e9fcd16c29b226db4397ed752a761cfce81e8\"\ndependencies = [\n \"tinyvec_macros\",\n]\n\n[[package]]\nname = \"tinyvec_macros\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20\"\n\n[[package]]\nname = \"tokio\"\nversion = \"1.42.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5cec9b21b0450273377fc97bd4c33a8acffc8c996c987a7c5b319a0083707551\"\ndependencies = [\n \"backtrace\",\n \"bytes\",\n \"libc\",\n \"mio\",\n \"parking_lot\",\n \"pin-project-lite\",\n \"signal-hook-registry\",\n \"socket2\",\n \"tokio-macros\",\n \"windows-sys 0.52.0\",\n]\n\n[[package]]\nname = \"tokio-macros\"\nversion = \"2.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"tokio-native-tls\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2\"\ndependencies = [\n \"native-tls\",\n \"tokio\",\n]\n\n[[package]]\nname = \"tokio-tungstenite\"\nversion = \"0.20.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"212d5dcb2a1ce06d81107c3d0ffa3121fe974b73f068c8282cb1c32328113b6c\"\ndependencies = [\n \"futures-util\",\n \"log\",\n \"native-tls\",\n \"tokio\",\n \"tokio-native-tls\",\n \"tungstenite\",\n]\n\n[[package]]\nname = \"tokio-util\"\nversion = \"0.7.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d7fcaa8d55a2bdd6b83ace262b016eca0d79ee02818c5c1bcdf0305114081078\"\ndependencies = [\n \"bytes\",\n \"futures-core\",\n \"futures-sink\",\n \"pin-project-lite\",\n \"tokio\",\n]\n\n[[package]]\nname = \"tokio-websockets\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bc307e407330d5f102fadaeec0d7ce10e30e60d2b20528962f2aed3c1000558\"\ndependencies = [\n \"base64\",\n \"bytes\",\n \"fastrand 1.9.0\",\n \"futures-util\",\n \"http\",\n \"httparse\",\n \"sha1_smol\",\n \"tokio\",\n \"tokio-util\",\n]\n\n[[package]]\nname = \"toml\"\nversion = \"0.5.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f4f7f0dd8d50a853a531c426359045b1998f04219d88799810762cd4ad314234\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"toml\"\nversion = \"0.8.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a1ed1f98e3fdc28d6d910e6737ae6ab1a93bf1985935a1193e68f93eeb68d24e\"\ndependencies = [\n \"serde\",\n \"serde_spanned\",\n \"toml_datetime\",\n \"toml_edit\",\n]\n\n[[package]]\nname = \"toml_datetime\"\nversion = \"0.6.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.22.22\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4ae48d6208a266e853d946088ed816055e556cc6028c5e8e2b84d9fa5dd7c7f5\"\ndependencies = [\n \"indexmap\",\n \"serde\",\n \"serde_spanned\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"trading_platform\"\nversion = \"0.1.0\"\ndependencies = [\n \"anyhow\",\n \"async-trait\",\n \"config\",\n \"env_logger\",\n \"futures\",\n \"futures-util\",\n \"log\",\n \"rust_decimal\",\n \"serde\",\n \"serde_json\",\n \"thiserror 1.0.69\",\n \"tokio\",\n \"tokio-tungstenite\",\n \"tokio-websockets\",\n \"url\",\n \"uuid\",\n \"zmq\",\n]\n\n[[package]]\nname = \"tungstenite\"\nversion = \"0.20.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9e3dac10fd62eaf6617d3a904ae222845979aec67c615d1c842b4002c7666fb9\"\ndependencies = [\n \"byteorder\",\n \"bytes\",\n \"data-encoding\",\n \"http\",\n \"httparse\",\n \"log\",\n \"native-tls\",\n \"rand\",\n \"sha1\",\n \"thiserror 1.0.69\",\n \"url\",\n \"utf-8\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.17.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825\"\n\n[[package]]\nname = \"ucd-trie\"\nversion = \"0.1.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971\"\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"adb9e6ca4f869e1180728b7950e35922a7fc6397f7b641499e8f3ef06e50dc83\"\n\n[[package]]\nname = \"url\"\nversion = \"2.5.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60\"\ndependencies = [\n \"form_urlencoded\",\n \"idna\",\n \"percent-encoding\",\n]\n\n[[package]]\nname = \"utf-8\"\nversion = \"0.7.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9\"\n\n[[package]]\nname = \"utf16_iter\"\nversion = \"1.0.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c8232dd3cdaed5356e0f716d285e4b40b932ac434100fe9b7e0e8e935b9e6246\"\n\n[[package]]\nname = \"utf8_iter\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be\"\n\n[[package]]\nname = \"uuid\"\nversion = \"1.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f8c5f0a0af699448548ad1a2fbf920fb4bee257eae39953ba95cb84891a0446a\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"vcpkg\"\nversion = \"0.2.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426\"\n\n[[package]]\nname = \"version-compare\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"852e951cb7832cb45cb1169900d19760cfa39b82bc0ea9c0e5a14ae88411c98b\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a\"\n\n[[package]]\nname = \"walkdir\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b\"\ndependencies = [\n \"same-file\",\n \"winapi-util\",\n]\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"winapi-util\"\nversion = \"0.1.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb\"\ndependencies = [\n \"windows-sys 0.59.0\",\n]\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.52.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.59.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-targets\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973\"\ndependencies = [\n \"windows_aarch64_gnullvm\",\n \"windows_aarch64_msvc\",\n \"windows_i686_gnu\",\n \"windows_i686_gnullvm\",\n \"windows_i686_msvc\",\n \"windows_x86_64_gnu\",\n \"windows_x86_64_gnullvm\",\n \"windows_x86_64_msvc\",\n]\n\n[[package]]\nname = \"windows_aarch64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3\"\n\n[[package]]\nname = \"windows_aarch64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469\"\n\n[[package]]\nname = \"windows_i686_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b\"\n\n[[package]]\nname = \"windows_i686_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66\"\n\n[[package]]\nname = \"windows_i686_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66\"\n\n[[package]]\nname = \"windows_x86_64_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78\"\n\n[[package]]\nname = \"windows_x86_64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d\"\n\n[[package]]\nname = \"windows_x86_64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec\"\n\n[[package]]\nname = \"winnow\"\nversion = \"0.6.20\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"36c1fec1a2bb5866f07c25f68c26e565c4c200aebb96d7e55710c19d3e8ac49b\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"write16\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d1890f4022759daae28ed4fe62859b1236caebfc61ede2f63ed4e695f3f6d936\"\n\n[[package]]\nname = \"writeable\"\nversion = \"0.5.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1e9df38ee2d2c3c5948ea468a8406ff0db0b29ae1ffde1bcf20ef305bcc95c51\"\n\n[[package]]\nname = \"wyz\"\nversion = \"0.5.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed\"\ndependencies = [\n \"tap\",\n]\n\n[[package]]\nname = \"yaml-rust\"\nversion = \"0.4.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"56c1936c4cc7a1c9ab21a1ebb602eb942ba868cbd44a99cb7cdc5892335e1c85\"\ndependencies = [\n \"linked-hash-map\",\n]\n\n[[package]]\nname = \"yoke\"\nversion = \"0.7.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"120e6aef9aa629e3d4f52dc8cc43a015c7724194c97dfaf45180d2daf2b77f40\"\ndependencies = [\n \"serde\",\n \"stable_deref_trait\",\n \"yoke-derive\",\n \"zerofrom\",\n]\n\n[[package]]\nname = \"yoke-derive\"\nversion = \"0.7.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2380878cad4ac9aac1e2435f3eb4020e8374b5f13c296cb75b4620ff8e229154\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n \"synstructure\",\n]\n\n[[package]]\nname = \"zerocopy\"\nversion = \"0.7.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0\"\ndependencies = [\n \"byteorder\",\n \"zerocopy-derive\",\n]\n\n[[package]]\nname = \"zerocopy-derive\"\nversion = \"0.7.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"zerofrom\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cff3ee08c995dee1859d998dea82f7374f2826091dd9cd47def953cae446cd2e\"\ndependencies = [\n \"zerofrom-derive\",\n]\n\n[[package]]\nname = \"zerofrom-derive\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"595eed982f7d355beb85837f651fa22e90b3c044842dc7f2c2842c086f295808\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n \"synstructure\",\n]\n\n[[package]]\nname = \"zeromq-src\"\nversion = \"0.2.6+4.3.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fc120b771270365d5ed0dfb4baf1005f2243ae1ae83703265cb3504070f4160b\"\ndependencies = [\n \"cc\",\n \"dircpy\",\n]\n\n[[package]]\nname = \"zerovec\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"aa2b893d79df23bfb12d5461018d408ea19dfafe76c2c7ef6d4eba614f8ff079\"\ndependencies = [\n \"yoke\",\n \"zerofrom\",\n \"zerovec-derive\",\n]\n\n[[package]]\nname = \"zerovec-derive\"\nversion = \"0.10.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6eafa6dfb17584ea3e2bd6e76e0cc15ad7af12b09abdd1ca55961bed9b1063c6\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.92\",\n]\n\n[[package]]\nname = \"zmq\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dd3091dd571fb84a9b3e5e5c6a807d186c411c812c8618786c3c30e5349234e7\"\ndependencies = [\n \"bitflags 1.3.2\",\n \"libc\",\n \"zmq-sys\",\n]\n\n[[package]]\nname = \"zmq-sys\"\nversion = \"0.12.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e8351dc72494b4d7f5652a681c33634063bbad58046c1689e75270908fdc864\"\ndependencies = [\n \"libc\",\n \"system-deps\",\n \"zeromq-src\",\n]\n",
  "src/config.rs": "use std::collections::HashMap;\nuse std::path::PathBuf;\nuse serde::{Deserialize, Serialize};\nuse config::{Config as ConfigLoader, ConfigError as ConfigLoaderError, File};\nuse thiserror::Error;\nuse log::{info, warn};\n\nuse crate::common::enums::{ExchangeName, StrategyName, BrokerName};\n\n#[derive(Error, Debug)]\npub enum ConfigError {\n    #[error(\"Failed to load configuration: {0}\")]\n    LoadError(String),\n    #[error(\"Invalid configuration: {0}\")]\n    ValidationError(String),\n    #[error(\"Missing required configuration: {0}\")]\n    MissingConfig(String),\n    #[error(\"Config Loader Error: {0}\")]\n    LoaderError(#[from] ConfigLoaderError)\n}\n\npub type Result<T> = std::result::Result<T, ConfigError>;\n\n/// Main configuration structure for the trading platform\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Config {\n    pub event_bus: EventBusConfig,\n    pub components: ComponentsConfig,\n}\n\nimpl Default for Config {\n    fn default() -> Self {\n        Self {\n            event_bus: EventBusConfig::default(),\n            components: ComponentsConfig::default(),\n        }\n    }\n}\n\nimpl Config {\n    /// Validates the configuration\n    pub fn validate(&self) -> Result<()> {\n        self.event_bus.validate()?;\n        self.components.validate()?;\n        Ok(())\n    }\n\n    /// Loads configuration from the specified file path\n    pub fn load_from_file(path: PathBuf) -> Result<Self> {\n        info!(\"Loading configuration from: {:?}\", path);\n\n        if !path.exists() {\n            return Err(ConfigError::LoadError(format!(\"Config file not found: {:?}\", path)));\n        }\n\n        let mut builder = ConfigLoader::builder();\n\n        // Add default values\n        builder = builder.set_default(\"event_bus.type\", \"zmq\")?;\n\n        // Load from file\n        builder = builder.add_source(File::from(path));\n\n        // Add environment variables\n        builder = builder.add_source(\n            config::Environment::with_prefix(\"TRADING_PLATFORM\")\n                .separator(\"_\")\n                .try_parsing(true)\n        );\n\n        let config: Self = builder.build()?.try_deserialize()?;\n        config.validate()?;\n\n        Ok(config)\n    }\n\n   /// Loads configuration from the default path\n    pub fn load() -> Result<Self> {\n        let config_path = std::env::var(\"CONFIG_PATH\")\n            .map(PathBuf::from)\n            .unwrap_or_else(|_| PathBuf::from(\"config.toml\"));\n\n        Self::load_from_file(config_path)\n    }\n}\n\n/// Event bus configuration\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct EventBusConfig {\n    pub type_name: String,\n    pub zmq_address: String,\n}\n\nimpl Default for EventBusConfig {\n    fn default() -> Self {\n        Self {\n            type_name: \"zmq\".to_string(),\n            zmq_address: \"tcp://127.0.0.1:5555\".to_string(),\n        }\n    }\n}\n\nimpl EventBusConfig {\n    pub fn validate(&self) -> Result<()> {\n        if self.type_name.is_empty() {\n            return Err(ConfigError::ValidationError(\"Event bus type cannot be empty\".to_string()));\n        }\n        if self.zmq_address.is_empty() {\n            return Err(ConfigError::ValidationError(\"ZMQ address cannot be empty\".to_string()));\n        }\n        Ok(())\n    }\n}\n\n/// Components configuration\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct ComponentsConfig {\n    pub exchanges: Option<HashMap<ExchangeName, ExchangeConfig>>,\n    pub strategies: Option<HashMap<StrategyName, StrategyConfig>>,\n    pub broker: Option<HashMap<BrokerName, BrokerConfig>>,\n    pub data_transformations: Option<HashMap<String, DataTransformationConfig>>,\n    pub ui: Option<SubscriberConfig>,\n    pub logging: Option<SubscriberConfig>,\n    pub metrics: Option<SubscriberConfig>,\n    pub audit: Option<SubscriberConfig>,\n}\n\nimpl Default for ComponentsConfig {\n    fn default() -> Self {\n        Self {\n            exchanges: Some(HashMap::new()),\n            strategies: Some(HashMap::new()),\n            broker: Some(HashMap::new()),\n            data_transformations: Some(HashMap::new()),\n            ui: Some(SubscriberConfig::default()),\n            logging: Some(SubscriberConfig::default()),\n            metrics: Some(SubscriberConfig::default()),\n            audit: Some(SubscriberConfig::default()),\n        }\n    }\n}\n\nimpl ComponentsConfig {\n    pub fn validate(&self) -> Result<()> {\n        if let Some(exchanges) = &self.exchanges {\n            for (name, config) in exchanges {\n                config.validate().map_err(|e|\n                    ConfigError::ValidationError(format!(\"Exchange {}: {}\", name, e)))?;\n            }\n        }\n\n        if let Some(strategies) = &self.strategies {\n            for (name, config) in strategies {\n                config.validate().map_err(|e|\n                    ConfigError::ValidationError(format!(\"Strategy {}: {}\", name, e)))?;\n            }\n        }\n\n        if let Some(brokers) = &self.broker {\n            for (name, config) in brokers {\n                config.validate().map_err(|e|\n                    ConfigError::ValidationError(format!(\"Broker {}: {}\", name, e)))?;\n            }\n        }\n\n        Ok(())\n    }\n}\n/// Subscriber configuration\n#[derive(Debug, Deserialize, Serialize, Clone, Default)]\npub struct SubscriberConfig {\n    pub enabled: bool,\n    pub topics: Vec<String>,\n    pub level: Option<String>,\n    pub file: Option<String>\n}\n\n\nimpl SubscriberConfig {\n    pub fn validate(&self) -> Result<()> {\n        if self.enabled && self.topics.is_empty() {\n            return Err(ConfigError::ValidationError(\"Enabled subscriber must have at least one topic\".to_string()));\n        }\n        Ok(())\n    }\n}\n/// Exchange configuration\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct ExchangeConfig {\n    pub api_url: String,\n    pub pairs: Vec<String>,\n}\n\nimpl ExchangeConfig {\n    pub fn validate(&self) -> Result<()> {\n        if self.api_url.is_empty() {\n            return Err(ConfigError::ValidationError(\"API URL cannot be empty\".to_string()));\n        }\n        if self.pairs.is_empty() {\n            return Err(ConfigError::ValidationError(\"At least one trading pair must be specified\".to_string()));\n        }\n        Ok(())\n    }\n}\n\n/// Broker configuration\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct BrokerConfig {\n     pub host: String,\n     pub port: u16,\n     pub client_id: u16,\n     pub account_id: String,\n     pub paper_trading: bool,\n     pub max_retries: u32,\n     pub timeout: u64,\n}\n\nimpl BrokerConfig {\n    pub fn validate(&self) -> Result<()> {\n        if self.host.is_empty() {\n            return Err(ConfigError::ValidationError(\"Broker host cannot be empty\".to_string()));\n        }\n         if self.port == 0{\n            return Err(ConfigError::ValidationError(\"Broker port cannot be zero\".to_string()));\n         }\n        Ok(())\n    }\n}\n\n/// Strategy configuration\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct StrategyConfig {\n    pub params: HashMap<String, String>,\n    pub enabled: bool,\n}\n\nimpl StrategyConfig {\n    pub fn validate(&self) -> Result<()> {\n        if self.enabled && self.params.is_empty() {\n            return Err(ConfigError::ValidationError(\"Enabled strategy must have parameters\".to_string()));\n        }\n        Ok(())\n    }\n}\n/// Data transformation configuration\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct DataTransformationConfig {\n    pub source_topic: String,\n    pub destination_topic: String,\n    pub enabled: bool,\n    pub params: HashMap<String, String>,\n}\n\nimpl DataTransformationConfig {\n    pub fn validate(&self) -> Result<()> {\n        if self.enabled {\n            if self.source_topic.is_empty() {\n                return Err(ConfigError::ValidationError(\"Source topic cannot be empty\".to_string()));\n            }\n            if self.destination_topic.is_empty() {\n                return Err(ConfigError::ValidationError(\"Destination topic cannot be empty\".to_string()));\n            }\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_config_validation() {\n        let config = Config::default();\n        assert!(config.validate().is_ok());\n    }\n\n    #[test]\n    fn test_exchange_config_validation() {\n        let config = ExchangeConfig {\n            api_url: \"\".to_string(),\n            pairs: vec![],\n        };\n        assert!(config.validate().is_err());\n\n        let config = ExchangeConfig {\n            api_url: \"http://example.com\".to_string(),\n            pairs: vec![\"BTC/USD\".to_string()],\n        };\n        assert!(config.validate().is_ok());\n    }\n\n    #[test]\n    fn test_subscriber_config_validation() {\n        let config = SubscriberConfig {\n            enabled: true,\n            topics: vec![],\n            level:None,\n            file:None\n        };\n        assert!(config.validate().is_err());\n\n        let config = SubscriberConfig {\n            enabled: true,\n            topics: vec![\"topic1\".to_string()],\n            level:Some(\"info\".to_string()),\n            file:Some(\"file.log\".to_string())\n        };\n        assert!(config.validate().is_ok());\n    }\n}\n",
  "src/main.rs": "// src/main.rs\nmod config;\nmod domain;\nmod infra;\nmod common;\nmod ui;\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse log::{error, info, warn};\nuse tokio::time::{sleep, Duration};\n\nuse crate::config::Config;\nuse crate::common::types::Error;\nuse crate::common::utils::shutdown::ShutdownSignal;\nuse crate::infra::event_bus::zmq::ZMQEventBus;\nuse crate::domain::interfaces::{EventBusPort, DataAdapterPort, StrategyPort, BrokerPort, Subscriber};\nuse crate::domain::events::{DomainEvent, TradeSignalEvent, OrderStatusEvent};\nuse crate::domain::models::{Order, StrategyConfig};\n\nuse crate::infra::adapters::{\n    kraken::KrakenAdapter,\n    coinbase::CoinbaseAdapter\n};\nuse crate::infra::execution::manager::ExecutionManager;\nuse crate::infra::broker_adapters::interactive_broker_adapter::InteractiveBrokerAdapter;\nuse crate::domain::strategies::{\n    arbitrage::ArbitrageStrategy,\n    mean_reversion::MeanReversionStrategy\n};\nuse crate::common::enums::{ExchangeName, StrategyName, BrokerName};\nuse crate::common::constants::{\n    DATA_TOPIC,\n    TRADES_TOPIC,\n    ORDERS_TOPIC,\n    LOG_TOPIC,\n    METRICS_TOPIC,\n    AUDIT_TOPIC\n};\nuse crate::ui::{\n    console::ConsoleUI,\n    logger::Logger,\n    metrics::MetricsSubscriber,\n    audit::AuditSubscriber\n};\n\n/// Trading platform main structure\npub struct TradingPlatform {\n    config: Config,\n    event_bus: Arc<ZMQEventBus>,\n    data_adapters: HashMap<String, Box<dyn DataAdapterPort<DomainEvent> + Send + Sync>>,\n    strategies: HashMap<String, Box<dyn StrategyPort<EventType = DomainEvent, TradeSignalType = TradeSignalEvent> + Send + Sync>>,\n    broker_adapters: HashMap<String, Box<dyn BrokerPort<OrderStatusType = OrderStatusEvent, OrderType = Order> + Send + Sync>>,\n    execution_manager: Arc<Mutex<ExecutionManager>>,\n    shutdown: ShutdownSignal,\n}\n\nimpl TradingPlatform {\n    fn initialize_data_adapters(config: &Config) -> Result<HashMap<String, Box<dyn DataAdapterPort<DomainEvent> + Send + Sync>>, Error> {\n        let mut adapters = HashMap::new();\n\n        if let Some(exchanges) = &config.components.exchanges {\n            for (name, config) in exchanges {\n                let adapter: Box<dyn DataAdapterPort<DomainEvent> + Send + Sync> = match name {\n                    ExchangeName::Kraken => Box::new(KrakenAdapter::new(config.clone())?),\n                    ExchangeName::Coinbase => Box::new(CoinbaseAdapter::new(config.clone())),\n                    _ => {\n                        warn!(\"Exchange {} not implemented\", name);\n                        continue;\n                    }\n                };\n                adapters.insert(name.to_string().to_lowercase(), adapter);\n            }\n        }\n\n        if adapters.is_empty() {\n            return Err(Error::ConfigError(\"No data adapters configured\".to_string()));\n        }\n\n        Ok(adapters)\n    }\n\n    fn initialize_strategies(config: &Config) -> Result<HashMap<String, Box<dyn StrategyPort<EventType = DomainEvent, TradeSignalType = TradeSignalEvent> + Send + Sync>>, Error> {\n        let mut strategies = HashMap::new();\n\n        if let Some(strategy_configs) = &config.components.strategies {\n            for (name, config) in strategy_configs {\n                let strategy: Box<dyn StrategyPort<EventType = DomainEvent, TradeSignalType = TradeSignalEvent> + Send + Sync> = match name {\n                    StrategyName::Arbitrage => Box::new(ArbitrageStrategy::new(\n                        StrategyConfig::new(name.clone(), config.params.clone(), config.enabled),\n                        vec![TRADES_TOPIC.to_string()]\n                    )),\n                    StrategyName::MeanReversion => Box::new(MeanReversionStrategy::new(\n                        StrategyConfig::new(name.clone(), config.params.clone(), config.enabled),\n                        vec![TRADES_TOPIC.to_string()]\n                    )),\n                    _ => {\n                        warn!(\"Strategy {} not implemented\", name);\n                        continue;\n                    }\n                };\n                strategies.insert(name.to_string().to_lowercase(), strategy);\n            }\n        }\n\n        if strategies.is_empty() {\n            return Err(Error::ConfigError(\"No strategies configured\".to_string()));\n        }\n\n        Ok(strategies)\n    }\n\n    fn initialize_broker_adapters(config: &Config) -> Result<HashMap<String, Box<dyn BrokerPort<OrderStatusType = OrderStatusEvent, OrderType = Order> + Send + Sync>>, Error> {\n        let mut brokers = HashMap::new();\n\n        if let Some(broker_configs) = &config.components.broker {\n            for (name, config) in broker_configs {\n                let broker: Box<dyn BrokerPort<OrderStatusType = OrderStatusEvent, OrderType = Order> + Send + Sync> = match name {\n                    BrokerName::InteractiveBrokers => Box::new(InteractiveBrokerAdapter::new(config.clone())?),\n                    _ => {\n                        warn!(\"Broker {} not implemented\", name);\n                        continue;\n                    }\n                };\n                brokers.insert(name.to_string().to_lowercase(), broker);\n            }\n        }\n\n        if brokers.is_empty() {\n            return Err(Error::ConfigError(\"No broker adapters configured\".to_string()));\n        }\n\n        Ok(brokers)\n    }\n\n    async fn new(config: Config) -> Result<Self, Error> {\n        let event_bus = Arc::new(ZMQEventBus::new(config.event_bus.zmq_address.clone())?);\n        let data_adapters = Self::initialize_data_adapters(&config)?;\n        let strategies = Self::initialize_strategies(&config)?;\n        let broker_adapters = Self::initialize_broker_adapters(&config)?;\n        let broker = broker_adapters.get(\"interactivebrokers\")\n            .ok_or_else(|| Error::ConfigError(\"InteractiveBrokers not configured\".to_string()))?;\n\n        let execution_manager = Arc::new(Mutex::new(ExecutionManager::new(Box::clone(broker))));\n\n        Ok(Self {\n            config,\n            event_bus,\n            data_adapters,\n            strategies,\n            broker_adapters,\n            execution_manager,\n            shutdown: ShutdownSignal::new(),\n        })\n    }\n\n    async fn start_subscriber(\n        &self,\n        mut subscriber: Box<dyn Subscriber<DomainEvent> + Send + Sync>,\n        topic: String,\n        name: String,\n    ) -> Result<(), Error> {\n        subscriber.start().await?;\n\n        let event_bus = Arc::clone(&self.event_bus);\n        let name_clone = name.clone();\n\n        subscriber.subscribe(move |event| {\n            let event_bus = Arc::clone(&event_bus);\n            let topic = topic.clone();\n            let name = name_clone.clone();\n\n            tokio::spawn(async move {\n                if let Err(e) = event_bus.publish(event, topic).await {\n                    error!(\"Failed to publish event for {}: {}\", name, e);\n                }\n            });\n        }).await?;\n\n        info!(\"{} subscriber started\", name);\n        Ok(())\n    }\n\n    async fn start_subscribers(&self) -> Result<(), Error> {\n        if let Some(ui_config) = &self.config.components.ui {\n            if ui_config.enabled {\n                let ui = ConsoleUI::new(ui_config.topics.clone())?;\n                self.start_subscriber(Box::new(ui), LOG_TOPIC.to_string(), \"UI\".to_string()).await?;\n            }\n        }\n\n        if let Some(log_config) = &self.config.components.logging {\n            if log_config.enabled {\n                let logger = Logger::new(log_config.topics.clone())?;\n                self.start_subscriber(Box::new(logger), LOG_TOPIC.to_string(), \"Logger\".to_string()).await?;\n            }\n        }\n\n        if let Some(metrics_config) = &self.config.components.metrics {\n            if metrics_config.enabled {\n                let metrics = MetricsSubscriber::new(metrics_config.topics.clone())?;\n                self.start_subscriber(Box::new(metrics), METRICS_TOPIC.to_string(), \"Metrics\".to_string()).await?;\n            }\n        }\n\n        if let Some(audit_config) = &self.config.components.audit {\n            if audit_config.enabled {\n                let audit = AuditSubscriber::new(audit_config.topics.clone())?;\n                self.start_subscriber(Box::new(audit), AUDIT_TOPIC.to_string(), \"Audit\".to_string()).await?;\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn start_data_adapters(&self) -> Result<(), Error> {\n        for (name, adapter) in &self.data_adapters {\n            let adapter = Arc::new(adapter);\n            let event_bus = Arc::clone(&self.event_bus);\n            let name = name.clone();\n            let sink_topics = adapter.get_sink_topics();\n\n            adapter.start(move |event| {\n                let event_bus = Arc::clone(&event_bus);\n                let name = name.clone();\n                let topics = sink_topics.clone();\n\n                tokio::spawn(async move {\n                    for topic in topics {\n                        if let Err(e) = event_bus.publish(event.clone(), topic).await {\n                            error!(\"Failed to publish event for adapter {}: {}\", name, e);\n                        }\n                    }\n                });\n            }).await?;\n\n            info!(\"Started data adapter: {}\", name);\n        }\n        Ok(())\n    }\n\n    async fn start_strategies(&self) -> Result<(), Error> {\n        for (name, strategy) in &self.strategies {\n            let strategy = Arc::new(strategy);\n            let event_bus = Arc::clone(&self.event_bus);\n            let name = name.clone();\n\n            let config = strategy.get_strategy_config().await?;\n            if !config.enabled {\n                info!(\"Strategy {} is not enabled\", name);\n                continue;\n            }\n\n            strategy.start(move |signal| {\n                let event_bus = Arc::clone(&event_bus);\n                let name = name.clone();\n\n                tokio::spawn(async move {\n                    if let Err(e) = event_bus\n                        .publish(DomainEvent::TradeSignal(signal), TRADES_TOPIC.to_string())\n                        .await \n                    {\n                        error!(\"Failed to publish signal for strategy {}: {}\", name, e);\n                    }\n                });\n            }).await?;\n\n            // Subscribe to market data events for this strategy\n            let strategy_clone = Arc::clone(&strategy);\n            let name_clone = name.clone();\n            let event_bus_clone = Arc::clone(&event_bus);\n\n            event_bus.subscribe_many(strategy.get_source_topics(), move |event| {\n                let strategy = Arc::clone(&strategy_clone);\n                let event_bus = Arc::clone(&event_bus_clone);\n                let name = name_clone.clone();\n\n                tokio::spawn(async move {\n                    match strategy.analyze_market_data(event).await {\n                        Ok(signals) => {\n                            for signal in signals {\n                                if let Err(e) = event_bus\n                                    .publish(DomainEvent::TradeSignal(signal), TRADES_TOPIC.to_string())\n                                    .await \n                                {\n                                    error!(\"Failed to publish trade signal for {}: {}\", name, e);\n                                }\n                            }\n                        }\n                        Err(e) => error!(\"Error in strategy {}: {}\", name, e),\n                    }\n                });\n            }).await?;\n\n            info!(\"Started strategy: {}\", name);\n        }\n        Ok(())\n    }\n\n    async fn start_execution_manager(&self) -> Result<(), Error> {\n        let execution_manager = Arc::clone(&self.execution_manager);\n        let event_bus = Arc::clone(&self.event_bus);\n\n        // Subscribe to trade signals\n        let exec_clone = Arc::clone(&execution_manager);\n        event_bus.subscribe(TRADES_TOPIC.to_string(), move |event| {\n            let exec = Arc::clone(&exec_clone);\n            tokio::spawn(async move {\n                if let DomainEvent::TradeSignal(signal) = event {\n                    if let Err(e) = exec.lock().await.handle_trade_signal(signal).await {\n                        error!(\"Error handling trade signal: {}\", e);\n                    }\n                }\n            });\n        }).await?;\n\n        // Start execution manager\n        let exec_manager = execution_manager.lock().await;\n        exec_manager.start(move |event| {\n            let event_bus = Arc::clone(&event_bus);\n            tokio::spawn(async move {\n                if let Err(e) = event_bus.publish(DomainEvent::OrderStatus(event), ORDER_TOPIC.to_string()).await {\n                    error!(\"Failed to publish order status: {}\", e);\n                }\n            });\n        }).await?;\n\n        info!(\"Execution Manager started\");\n        Ok(())\n    }\n\n    pub async fn run(&self) -> Result<(), Error> {\n        self.start_subscribers().await?;\n        self.start_data_adapters().await?;\n        self.start_strategies().await?;\n        self.start_execution_manager().await?;\n\n        while !self.shutdown.is_shutdown() {\n            sleep(Duration::from_secs(1)).await;\n        }\n\n        info!(\"Shutting down trading platform...\");\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Error> {\n    env_logger::init();\n\n    let config = Config::load()?;\n    let platform = TradingPlatform::new(config).await?;\n\n    if let Err(e) = platform.run().await {\n        error!(\"Error running the platform: {}\", e);\n    }\n\n    Ok(())\n}\n",
  "src/lib.rs": "//! Trading platform core library\n//!\n//! This library provides the core functionality for the trading platform,\n//! including common types, enums, and constants used throughout the system.\n\npub mod common {\n    /// Common error types for the trading platform\n    pub mod types {\n        use thiserror::Error;\n\n        /// Result type alias using our custom error type\n        pub type Result<T> = std::result::Result<T, Error>;\n\n        #[derive(Debug, Error)]\n        pub enum Error {\n            #[error(\"IO error: {0}\")]\n            IoError(#[from] std::io::Error),\n\n            #[error(\"Configuration error: {0}\")]\n            ConfigError(String),\n\n            #[error(\"Validation error: {0}\")]\n            ValidationError(String),\n\n            #[error(\"Connection error: {0}\")]\n            ConnectionError(String),\n\n            #[error(\"Serialization error: {0}\")]\n            SerializationError(String),\n\n            #[error(\"Parse error: {0}\")]\n            ParseError(String),\n\n            #[error(\"Operation error: {0}\")]\n            OperationError(String),\n\n            #[error(\"Publish error: {0}\")]\n            PublishError(String),\n\n            #[error(\"Subscription error: {0}\")]\n            SubscriptionError(String),\n\n            #[error(\"Network error: {0}\")]\n            NetworkError(String),\n\n            #[error(\"Exchange error: {0}\")]\n            ExchangeError(String),\n\n            #[error(\"Strategy error: {0}\")]\n            StrategyError(String),\n\n            #[error(\"Broker error: {0}\")]\n            BrokerError(String),\n\n            #[error(\"Database error: {0}\")]\n            DatabaseError(String),\n\n            #[error(\"Unknown error: {0}\")]\n            Unknown(String),\n        }\n    }\n\n    /// Common enums used throughout the platform\n    pub mod enums {\n        use serde::{Deserialize, Serialize};\n        use std::fmt;\n\n        /// Supported exchanges\n        #[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\n        pub enum ExchangeName {\n            Kraken,\n            Coinbase,\n            Binance,\n            Bitfinex,\n            FTX,\n        }\n\n        impl fmt::Display for ExchangeName {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(f, \"{:?}\", self)\n            }\n        }\n\n        /// Available trading strategies\n        #[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\n        pub enum StrategyName {\n            Arbitrage,\n            MeanReversion,\n            Momentum,\n            MarketMaking,\n            StatisticalArbitrage,\n        }\n\n        impl fmt::Display for StrategyName {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(f, \"{:?}\", self)\n            }\n        }\n\n        /// Supported brokers\n        #[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\n        pub enum BrokerName {\n            InteractiveBrokers,\n            AlpacaMarkets,\n            TDAmeritrade,\n        }\n\n        impl fmt::Display for BrokerName {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(f, \"{:?}\", self)\n            }\n        }\n\n        /// Order types\n        #[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\n        pub enum OrderType {\n            Market,\n            Limit,\n            StopLoss,\n            StopLimit,\n            TrailingStop,\n        }\n\n        /// Trading side\n        #[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\n        #[serde(rename_all = \"UPPERCASE\")]\n        pub enum TradeSide {\n            Buy,\n            Sell,\n        }\n    }\n\n    /// Platform-wide constants\n    pub mod constants {\n        /// Topic names for the event bus\n        pub mod topics {\n            pub const DATA: &str = \"data\";\n            pub const TRADES: &str = \"trades\";\n            pub const ORDERS: &str = \"orders\";\n            pub const LOG: &str = \"log\";\n            pub const METRICS: &str = \"metrics\";\n            pub const AUDIT: &str = \"audit\";\n        }\n\n        /// System-wide timeouts\n        pub mod timeouts {\n            pub const DEFAULT_TIMEOUT_MS: u64 = 5000;\n            pub const NETWORK_TIMEOUT_MS: u64 = 10000;\n            pub const ORDER_TIMEOUT_MS: u64 = 30000;\n        }\n\n        /// Rate limiting constants\n        pub mod rate_limits {\n            pub const MAX_REQUESTS_PER_SECOND: u32 = 10;\n            pub const MAX_ORDERS_PER_SECOND: u32 = 5;\n        }\n    }\n}\n\n// Re-export commonly used types\npub use common::types::{Error, Result};\npub use common::enums::{ExchangeName, StrategyName, BrokerName, OrderType, TradeSide};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_enum_display() {\n        assert_eq!(ExchangeName::Kraken.to_string(), \"Kraken\");\n        assert_eq!(StrategyName::Arbitrage.to_string(), \"Arbitrage\");\n        assert_eq!(BrokerName::InteractiveBrokers.to_string(), \"InteractiveBrokers\");\n    }\n\n    #[test]\n    fn test_error_display() {\n        let err = Error::ValidationError(\"test error\".to_string());\n        assert_eq!(err.to_string(), \"Validation error: test error\");\n    }\n}\n",
  "src/common/mod.rs": "pub mod types;\npub mod enums;\npub mod constants;\npub mod utils;\n",
  "src/common/types.rs": "use thiserror::Error;\n\n/// Result type alias using our custom error type\npub type Result<T> = std::result::Result<T, Error>;\n\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Configuration error: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Validation error: {0}\")]\n    ValidationError(String),\n\n    #[error(\"Connection error: {0}\")]\n    ConnectionError(String),\n\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n\n    #[error(\"Parse error: {0}\")]\n    ParseError(String),\n\n    #[error(\"Operation error: {0}\")]\n    OperationError(String),\n\n    #[error(\"Publish error: {0}\")]\n    PublishError(String),\n\n    #[error(\"Subscription error: {0}\")]\n    SubscriptionError(String),\n\n    #[error(\"Network error: {0}\")]\n    NetworkError(String),\n\n    #[error(\"Exchange error: {0}\")]\n    ExchangeError(String),\n\n    #[error(\"Strategy error: {0}\")]\n    StrategyError(String),\n\n    #[error(\"Broker error: {0}\")]\n    BrokerError(String),\n\n    #[error(\"Database error: {0}\")]\n    DatabaseError(String),\n\n    #[error(\"Unknown error: {0}\")]\n    Unknown(String),\n}\n",
  "src/common/constants.rs": "// src/common/constants.rs\npub const DATA_TOPIC: &str = \"data\";\npub const TRADES_TOPIC: &str = \"trades\";\npub const ORDERS_TOPIC: &str = \"orders\"; // Note: Changed from ORDER_TOPIC\npub const LOG_TOPIC: &str = \"log\";\npub const METRICS_TOPIC: &str = \"metrics\";\npub const AUDIT_TOPIC: &str = \"audit\";\n\npub mod topics {\n    pub use super::*;\n}\n\npub mod timeouts {\n    pub const DEFAULT_TIMEOUT_MS: u64 = 5000;\n    pub const NETWORK_TIMEOUT_MS: u64 = 10000;\n    pub const ORDER_TIMEOUT_MS: u64 = 30000;\n}\n\npub mod rate_limits {\n    pub const MAX_REQUESTS_PER_SECOND: u32 = 10;\n    pub const MAX_ORDERS_PER_SECOND: u32 = 5;\n}\n",
  "src/common/utils.rs": "use crate::common::types::Error;\nuse crate::domain::events::DomainEvent;\nuse crate::domain::interfaces::EventBusPort;\nuse log::error;\n\npub async fn publish_event<T>(\n    event_bus: &T,\n    event: T::EventType,\n    topic: String,\n) -> Result<(), Error>\nwhere\n    T: EventBusPort,\n{\n    event_bus\n        .publish(event, topic)\n        .await\n        .map_err(|e| {\n            error!(\"Error publishing event to topic: {}\", e);\n            e\n        })\n}\n\n\npub fn generic_error_handler(e: anyhow::Error) {\n    error!(\"Error on component: {}\", e);\n}\n",
  "src/common/enums.rs": "use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Supported exchanges\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\npub enum ExchangeName {\n    Kraken,\n    Coinbase,\n    Binance,\n    Bitfinex,\n    FTX,\n}\n\nimpl fmt::Display for ExchangeName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n/// Available trading strategies\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\npub enum StrategyName {\n    Arbitrage,\n    MeanReversion,\n    Momentum,\n    MarketMaking,\n    StatisticalArbitrage,\n}\n\nimpl fmt::Display for StrategyName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n/// Supported brokers\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\npub enum BrokerName {\n    InteractiveBrokers,\n    AlpacaMarkets,\n    TDAmeritrade,\n}\n\nimpl fmt::Display for BrokerName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n/// Order types\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\npub enum OrderType {\n    Market,\n    Limit,\n    StopLoss,\n    StopLimit,\n    TrailingStop,\n}\n\n/// Trading side\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum TradeSide {\n    Buy,\n    Sell,\n}\n",
  "src/common/shutdown.rs": "pub mod shutdown;\n\nuse crate::common::types::Error;\nuse crate::domain::events::DomainEvent;\nuse crate::domain::interfaces::EventBusPort;\nuse log::error;\n\npub async fn publish_event<T: EventBusPort>(\n    event_bus: &T,\n    event: DomainEvent,\n    topic: String,\n) -> Result<(), Error> {\n    event_bus\n        .publish(event, topic)\n        .await\n        .map_err(|e| {\n            error!(\"Error publishing event to topic: {}\", e);\n            e\n        })\n}\n\npub fn generic_error_handler(e: anyhow::Error) {\n    error!(\"Error on component: {}\", e);\n}\n\n",
  "src/common/utils/mod.rs": "pub mod shutdown;\n\nuse crate::common::types::Error;\n\npub async fn publish_event<T, E>(\n    event_bus: &T,\n    event: E,\n    topic: String,\n) -> Result<(), Error>\nwhere\n    T: crate::domain::interfaces::EventBusPort<EventType = E>,\n{\n    event_bus\n        .publish(event, topic)\n        .await\n        .map_err(|e| {\n            log::error!(\"Error publishing event to topic: {}\", e);\n            e\n        })\n}\n\n",
  "src/common/utils/shutdown.rs": "// src/common/utils/shutdown.rs\nuse std::sync::Arc;\nuse tokio::sync::broadcast;\n\n#[derive(Clone)]\npub struct ShutdownSignal {\n    sender: Arc<broadcast::Sender<()>>,\n}\n\nimpl ShutdownSignal {\n    pub fn new() -> Self {\n        let (sender, _) = broadcast::channel(1);\n        Self {\n            sender: Arc::new(sender),\n        }\n    }\n\n    pub fn signal(&self) {\n        let _ = self.sender.send(());\n    }\n\n    pub async fn wait(&self) {\n        let mut rx = self.sender.subscribe();\n        let _ = rx.recv().await;\n    }\n\n    pub fn is_shutdown(&self) -> bool {\n        self.sender.receiver_count() == 0\n    }\n}\n",
  "src/infra/mod.rs": "pub mod adapters;\npub mod broker_adapters;\npub mod event_bus;\npub mod execution;\n",
  "src/infra/adapters/mod.rs": "pub mod kraken;\npub mod coinbase;\npub mod exchange;\n",
  "src/infra/adapters/coinbase.rs": "use async_trait::async_trait;\nuse futures_util::StreamExt;\nuse log::{error, info};\nuse serde_json::from_str;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse tokio_tungstenite::{\n    connect_async,\n    tungstenite::protocol::Message,\n    WebSocketStream,\n    MaybeTlsStream\n};\nuse tokio::net::TcpStream;\nuse url::Url;\n\nuse crate::common::enums::ExchangeName;\nuse crate::common::types::Error;\nuse crate::config::ExchangeConfig;\nuse crate::domain::events::{DomainEvent, PriceUpdateEvent, ExchangeData};\nuse crate::domain::interfaces::DataAdapterPort;\nuse crate::infra::adapters::exchange::{ExchangeAdapter, ExchangeAdapterImpl};\n\ntype WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;\n\n/// Adapter for connecting to and processing data from Coinbase\n#[derive(Debug)]\npub struct CoinbaseAdapter {\n    base: ExchangeAdapterImpl,\n    socket: Arc<Mutex<Option<WsStream>>>,\n}\n\nimpl CoinbaseAdapter {\n    /// Creates a new CoinbaseAdapter instance\n    pub fn new(config: ExchangeConfig) -> Result<Self, Error> {\n        Ok(CoinbaseAdapter {\n            base: ExchangeAdapterImpl::new(config, ExchangeName::Coinbase)?,\n            socket: Arc::new(Mutex::new(None)),\n        })\n    }\n}\n\n#[async_trait]\nimpl ExchangeAdapter<DomainEvent> for CoinbaseAdapter {\n    fn get_api_url(&self) -> String {\n        self.base.get_api_url()\n    }\n\n    fn get_pairs(&self) -> Vec<String> {\n        self.base.get_pairs()\n    }\n\n    fn get_exchange_name(&self) -> ExchangeName {\n        self.base.get_exchange_name()\n    }\n}\n\n#[async_trait]\nimpl DataAdapterPort<DomainEvent> for CoinbaseAdapter {\n    async fn connect(&self) -> Result<(), Error> {\n        self.base.connect().await\n    }\n\n    async fn process_message(&self) -> Result<Option<DomainEvent>, Error> {\n        Ok(None)\n    }\n\n    async fn start<F>(&self, mut callback: F) -> Result<(), Error>\n    where\n        F: FnMut(DomainEvent) + Send + 'static,\n    {\n        let url = self.get_api_url();\n        let pairs = self.get_pairs();\n        info!(\"Starting Coinbase adapter for pairs {:?}\", pairs);\n\n        let subscribe_message = serde_json::json!({\n            \"type\": \"subscribe\",\n            \"product_ids\": pairs,\n            \"channels\": [\"ticker\"]\n        })\n        .to_string();\n\n        let url = Url::parse(&url)\n            .map_err(|e| Error::ConnectionError(format!(\"Invalid URL: {}\", e)))?;\n\n        let (ws_stream, _) = connect_async(url)\n            .await\n            .map_err(|e| Error::ConnectionError(format!(\"Failed to connect to Coinbase: {}\", e)))?;\n\n        let mut websocket = ws_stream;\n\n        websocket\n            .send(Message::Text(subscribe_message))\n            .await\n            .map_err(|e| Error::ConnectionError(format!(\"Failed to subscribe to Coinbase: {}\", e)))?;\n\n        info!(\"Subscribed to Coinbase\");\n\n        let socket = Arc::clone(&self.socket);\n        *socket.lock().await = Some(websocket);\n\n        let socket_clone = Arc::clone(&socket);\n\n        tokio::spawn(async move {\n            if let Some(mut ws) = socket_clone.lock().await.take() {\n                while let Some(msg_result) = ws.next().await {\n                    match msg_result {\n                        Ok(msg) => {\n                            if let Message::Text(text) = msg {\n                                match Self::process_coinbase_message(&text).await {\n                                    Ok(event) => {\n                                        if event.coinbase_data.is_some() {\n                                            callback(DomainEvent::PriceUpdate(event));\n                                        }\n                                    }\n                                    Err(e) => error!(\"Error parsing message from Coinbase: {}\", e),\n                                }\n                            }\n                        }\n                        Err(e) => {\n                            error!(\"Error receiving message from Coinbase: {}\", e);\n                            break;\n                        }\n                    }\n                }\n            }\n            error!(\"Coinbase WebSocket connection closed\");\n        });\n\n        Ok(())\n    }\n\n    async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping Coinbase adapter\");\n        if let Some(mut ws) = self.socket.lock().await.take() {\n            ws.close(None)\n                .await\n                .map_err(|e| Error::ConnectionError(e.to_string()))?;\n        }\n        Ok(())\n    }\n\n    fn get_sink_topics(&self) -> Vec<String> {\n        self.base.get_sink_topics()\n    }\n}\n\nimpl CoinbaseAdapter {\n    /// Process a message received from Coinbase WebSocket\n    async fn process_coinbase_message(message: &str) -> Result<PriceUpdateEvent, Error> {\n        let data: serde_json::Value = from_str(message)\n            .map_err(|e| Error::ParseError(format!(\"Failed to parse Coinbase message: {}\", e)))?;\n\n        match (\n            data.get(\"type\"),\n            data.get(\"price\"),\n            data.get(\"product_id\"),\n        ) {\n            (Some(msg_type), Some(price), Some(product_id)) if msg_type == \"ticker\" => {\n                let price = price\n                    .as_str()\n                    .ok_or_else(|| Error::ParseError(\"Invalid price format\".to_string()))?\n                    .parse::<f64>()\n                    .map_err(|e| Error::ParseError(format!(\"Failed to parse price: {}\", e)))?;\n\n                let symbol = product_id\n                    .as_str()\n                    .ok_or_else(|| Error::ParseError(\"Invalid product_id format\".to_string()))?\n                    .to_string();\n\n                Ok(PriceUpdateEvent {\n                    kraken_data: None,\n                    coinbase_data: Some(ExchangeData {\n                        exchange: ExchangeName::Coinbase,\n                        pair: symbol,\n                        price,\n                    }),\n                })\n            }\n            _ => {\n                // Return empty event for subscription acknowledgments and other non-ticker messages\n                Ok(PriceUpdateEvent {\n                    kraken_data: None,\n                    coinbase_data: None,\n                })\n            }\n        }\n    }\n\n    /// Validates the required fields in a message\n    fn validate_fields(data: &serde_json::Value) -> Result<(), Error> {\n        if data.get(\"type\").is_none() {\n            return Err(Error::ParseError(\"Missing 'type' field\".to_string()));\n        }\n        if data.get(\"price\").is_none() && data.get(\"type\") == Some(&serde_json::Value::String(\"ticker\".to_string())) {\n            return Err(Error::ParseError(\"Missing 'price' field in ticker message\".to_string()));\n        }\n        if data.get(\"product_id\").is_none() && data.get(\"type\") == Some(&serde_json::Value::String(\"ticker\".to_string())) {\n            return Err(Error::ParseError(\"Missing 'product_id' field in ticker message\".to_string()));\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_process_coinbase_message() {\n        let message = r#\"{\n            \"type\": \"ticker\",\n            \"price\": \"50000.50\",\n            \"product_id\": \"BTC-USD\"\n        }\"#;\n\n        let result = CoinbaseAdapter::process_coinbase_message(message).await.unwrap();\n\n        if let Some(data) = result.coinbase_data {\n            assert_eq!(data.exchange, ExchangeName::Coinbase);\n            assert_eq!(data.pair, \"BTC-USD\");\n            assert_eq!(data.price, 50000.50);\n        } else {\n            panic!(\"Expected Some(ExchangeData), got None\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_invalid_message() {\n        let message = r#\"{\n            \"type\": \"invalid\",\n            \"price\": \"not_a_number\",\n            \"product_id\": \"BTC-USD\"\n        }\"#;\n\n        let result = CoinbaseAdapter::process_coinbase_message(message).await.unwrap();\n        assert!(result.coinbase_data.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_process_subscription_message() {\n        let message = r#\"{\n            \"type\": \"subscriptions\",\n            \"channels\": [{\"name\": \"ticker\", \"product_ids\": [\"BTC-USD\"]}]\n        }\"#;\n\n        let result = CoinbaseAdapter::process_coinbase_message(message).await.unwrap();\n        assert!(result.coinbase_data.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_message_validation() {\n        let valid_message = serde_json::json!({\n            \"type\": \"ticker\",\n            \"price\": \"50000.50\",\n            \"product_id\": \"BTC-USD\"\n        });\n        assert!(CoinbaseAdapter::validate_fields(&valid_message).is_ok());\n\n        let invalid_message = serde_json::json!({\n            \"price\": \"50000.50\",\n            \"product_id\": \"BTC-USD\"\n        });\n        assert!(CoinbaseAdapter::validate_fields(&invalid_message).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_new_adapter() {\n        let config = ExchangeConfig {\n            api_url: \"wss://ws-feed.pro.coinbase.com\".to_string(),\n            pairs: vec![\"BTC-USD\".to_string()],\n        };\n        \n        let adapter = CoinbaseAdapter::new(config);\n        assert!(adapter.is_ok());\n    }\n}\n",
  "src/infra/adapters/kraken.rs": "use async_trait::async_trait;\nuse futures_util::StreamExt;\nuse log::{error, info};\nuse serde_json::from_str;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse tokio_tungstenite::{\n    connect_async,\n    tungstenite::protocol::Message,\n    WebSocketStream,\n    MaybeTlsStream\n};\nuse tokio::net::TcpStream;\nuse url::Url;\n\nuse crate::common::enums::ExchangeName;\nuse crate::common::types::Error;\nuse crate::config::ExchangeConfig;\nuse crate::domain::events::{DomainEvent, PriceUpdateEvent, ExchangeData};\nuse crate::domain::interfaces::DataAdapterPort;\nuse crate::infra::adapters::exchange::{ExchangeAdapter, ExchangeAdapterImpl};\n\ntype WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;\n\n/// Adapter for connecting to and processing data from Kraken exchange\n#[derive(Debug)]\npub struct KrakenAdapter {\n    base: ExchangeAdapterImpl,\n    socket: Arc<Mutex<Option<WsStream>>>,\n}\n\nimpl KrakenAdapter {\n    /// Creates a new KrakenAdapter instance\n    pub fn new(config: ExchangeConfig) -> Result<Self, Error> {\n        Ok(KrakenAdapter {\n            base: ExchangeAdapterImpl::new(config, ExchangeName::Kraken)?,\n            socket: Arc::new(Mutex::new(None)),\n        })\n    }\n}\n\n#[async_trait]\nimpl ExchangeAdapter<DomainEvent> for KrakenAdapter {\n    fn get_api_url(&self) -> String {\n        self.base.get_api_url()\n    }\n\n    fn get_pairs(&self) -> Vec<String> {\n        self.base.get_pairs()\n    }\n\n    fn get_exchange_name(&self) -> ExchangeName {\n        self.base.get_exchange_name()\n    }\n}\n\n#[async_trait]\nimpl DataAdapterPort<DomainEvent> for KrakenAdapter {\n    async fn connect(&self) -> Result<(), Error> {\n        self.base.connect().await\n    }\n\n    async fn process_message(&self) -> Result<Option<DomainEvent>, Error> {\n        Ok(None)\n    }\n\n    async fn start<F>(&self, mut callback: F) -> Result<(), Error>\n    where\n        F: FnMut(DomainEvent) + Send + 'static,\n    {\n        let url = self.get_api_url();\n        let pairs = self.get_pairs();\n        info!(\"Starting Kraken adapter for pairs {:?}\", pairs);\n\n        let subscribe_message = serde_json::json!({\n            \"event\": \"subscribe\",\n            \"pair\": pairs,\n            \"subscription\": {\"name\": \"ticker\"}\n        })\n        .to_string();\n\n        let url = Url::parse(&url)\n            .map_err(|e| Error::ConnectionError(format!(\"Invalid URL: {}\", e)))?;\n\n        let (ws_stream, _) = connect_async(url)\n            .await\n            .map_err(|e| Error::ConnectionError(format!(\"Failed to connect to Kraken: {}\", e)))?;\n\n        let mut websocket = ws_stream;\n\n        websocket\n            .send(Message::Text(subscribe_message))\n            .await\n            .map_err(|e| Error::ConnectionError(format!(\"Failed to subscribe to Kraken: {}\", e)))?;\n\n        info!(\"Subscribed to Kraken\");\n\n        let socket = Arc::clone(&self.socket);\n        *socket.lock().await = Some(websocket);\n\n        let socket_clone = Arc::clone(&socket);\n        let pairs_clone = pairs.clone();\n\n        tokio::spawn(async move {\n            if let Some(mut ws) = socket_clone.lock().await.take() {\n                while let Some(msg_result) = ws.next().await {\n                    match msg_result {\n                        Ok(msg) => {\n                            if let Message::Text(text) = msg {\n                                match Self::process_kraken_message(&text, &pairs_clone).await {\n                                    Ok(event) => {\n                                        // Only call callback if we have data\n                                        if event.kraken_data.is_some() {\n                                            callback(DomainEvent::PriceUpdate(event));\n                                        }\n                                    }\n                                    Err(e) => error!(\"Error parsing message from Kraken: {}\", e),\n                                }\n                            }\n                        }\n                        Err(e) => {\n                            error!(\"Error receiving message from Kraken: {}\", e);\n                            break;\n                        }\n                    }\n                }\n            }\n            error!(\"Kraken WebSocket connection closed\");\n        });\n\n        Ok(())\n    }\n\n    async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping Kraken adapter\");\n        if let Some(mut ws) = self.socket.lock().await.take() {\n            ws.close(None)\n                .await\n                .map_err(|e| Error::ConnectionError(e.to_string()))?;\n        }\n        Ok(())\n    }\n\n    fn get_sink_topics(&self) -> Vec<String> {\n        self.base.get_sink_topics()\n    }\n}\n\nimpl KrakenAdapter {\n    /// Process a message received from Kraken WebSocket\n    async fn process_kraken_message(message: &str, pairs: &[String]) -> Result<PriceUpdateEvent, Error> {\n        let data: serde_json::Value = from_str(message)\n            .map_err(|e| Error::ParseError(format!(\"Failed to parse Kraken message: {}\", e)))?;\n\n        if let Some(array) = data.as_array() {\n            // Ignore subscription confirmation messages and other non-ticker messages\n            if array.len() <= 3 {\n                return Ok(PriceUpdateEvent {\n                    kraken_data: None,\n                    coinbase_data: None,\n                });\n            }\n\n            let symbol = array[3].as_str()\n                .ok_or_else(|| Error::ParseError(\"Invalid symbol format\".to_string()))?;\n\n            // Verify this is a pair we're interested in\n            if !pairs.contains(&symbol.to_string()) {\n                return Ok(PriceUpdateEvent {\n                    kraken_data: None,\n                    coinbase_data: None,\n                });\n            }\n\n            if let Some(info) = array[1].as_object() {\n                // Extract the price from the 'c' field (last trade closed price)\n                if let Some(price) = info.get(\"c\")\n                    .and_then(|p| p.as_array())\n                    .and_then(|arr| arr.first())\n                    .and_then(|v| v.as_str()) \n                {\n                    let price = price.parse::<f64>()\n                        .map_err(|e| Error::ParseError(format!(\"Failed to parse price: {}\", e)))?;\n\n                    return Ok(PriceUpdateEvent {\n                        kraken_data: Some(ExchangeData {\n                            exchange: ExchangeName::Kraken,\n                            pair: symbol.to_string(),\n                            price,\n                        }),\n                        coinbase_data: None,\n                    });\n                }\n            }\n        }\n\n        Ok(PriceUpdateEvent {\n            kraken_data: None,\n            coinbase_data: None,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_process_kraken_message() {\n        let message = r#\"[\n            278,\n            {\"c\":[\"50000.5\",\"1.0\"]},\n            \"ticker\",\n            \"BTC/USD\"\n        ]\"#;\n\n        let pairs = vec![\"BTC/USD\".to_string()];\n        let result = KrakenAdapter::process_kraken_message(message, &pairs).await.unwrap();\n\n        if let Some(data) = result.kraken_data {\n            assert_eq!(data.exchange, ExchangeName::Kraken);\n            assert_eq!(data.pair, \"BTC/USD\");\n            assert_eq!(data.price, 50000.5);\n        } else {\n            panic!(\"Expected Some(ExchangeData), got None\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_process_invalid_message() {\n        let message = r#\"{\"invalid\": \"message\"}\"#;\n        let pairs = vec![\"BTC/USD\".to_string()];\n\n        let result = KrakenAdapter::process_kraken_message(message, &pairs).await.unwrap();\n        assert!(result.kraken_data.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_new_adapter() {\n        let config = ExchangeConfig {\n            api_url: \"wss://ws.kraken.com\".to_string(),\n            pairs: vec![\"BTC/USD\".to_string()],\n        };\n        \n        let adapter = KrakenAdapter::new(config);\n        assert!(adapter.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_process_subscription_message() {\n        let message = r#\"{\n            \"event\": \"subscriptionStatus\",\n            \"pair\": \"XBT/USD\",\n            \"status\": \"subscribed\",\n            \"subscription\": {\"name\": \"ticker\"}\n        }\"#;\n        \n        let pairs = vec![\"XBT/USD\".to_string()];\n        let result = KrakenAdapter::process_kraken_message(message, &pairs).await.unwrap();\n        assert!(result.kraken_data.is_none());\n    }\n}\n",
  "src/infra/adapters/exchange.rs": "use std::fmt::Debug;\nuse async_trait::async_trait;\nuse log::info;\n\nuse crate::common::types::Error;\nuse crate::common::enums::ExchangeName;\nuse crate::config::ExchangeConfig;\nuse crate::domain::interfaces::DataAdapterPort;\n/// Trait defining common functionality for exchange adapters\n#[async_trait]\npub trait ExchangeAdapter<T: Send + Sync + Debug>: DataAdapterPort<T> {\n    /// Returns the API URL for the exchange\n    fn get_api_url(&self) -> String;\n\n    /// Returns the trading pairs supported by the exchange\n    fn get_pairs(&self) -> Vec<String>;\n\n    /// Returns the exchange name\n    fn get_exchange_name(&self) -> ExchangeName;\n}\n\n/// Base implementation for exchange adapters\n#[derive(Debug, Clone)]\npub struct ExchangeAdapterImpl {\n    api_url: String,\n    pairs: Vec<String>,\n    exchange_name: ExchangeName,\n    sink_topics: Vec<String>,\n}\n\nimpl ExchangeAdapterImpl {\n    /// Creates a new ExchangeAdapterImpl instance\n    pub fn new(config: ExchangeConfig, name: ExchangeName) -> Result<Self, Error> {\n        // Validate configuration\n        if config.api_url.is_empty() {\n            return Err(Error::ValidationError(\"API URL cannot be empty\".to_string()));\n        }\n        if config.pairs.is_empty() {\n            return Err(Error::ValidationError(\"Trading pairs cannot be empty\".to_string()));\n        }\n\n        // Validate trading pairs format\n        for pair in &config.pairs {\n            if !Self::is_valid_trading_pair(pair) {\n                return Err(Error::ValidationError(format!(\"Invalid trading pair format: {}\", pair)));\n            }\n        }\n\n        let sink_topic = format!(\"price.feed.{}\", name.to_string().to_lowercase());\n\n        Ok(ExchangeAdapterImpl {\n            api_url: config.api_url,\n            pairs: config.pairs,\n            exchange_name: name,\n            sink_topics: vec![sink_topic],\n        })\n    }\n\n    /// Returns the sink topics for this adapter\n    pub fn get_sink_topics(&self) -> Vec<String> {\n        self.sink_topics.clone()\n    }\n\n    /// Validates trading pair format (e.g., \"BTC-USD\")\n    fn is_valid_trading_pair(pair: &str) -> bool {\n        let parts: Vec<&str> = pair.split('-').collect();\n        if parts.len() != 2 {\n            return false;\n        }\n\n        parts.iter().all(|p| {\n            !p.is_empty() && p.chars().all(|c| c.is_ascii_alphabetic())\n        })\n    }\n}\n #[async_trait]\n impl<T: Send + Sync + Debug> DataAdapterPort<T> for ExchangeAdapterImpl {\n     async fn connect(&self) -> Result<(), Error> {\n         info!(\"Connecting to exchange at {}\", self.get_api_url());\n         // Base implementation just logs - specific adapters will override this\n         Ok(())\n     }\n\n     async fn process_message(&self) -> Result<Option<T>, Error> {\n         // Base implementation returns None - specific adapters will override this\n         Ok(None)\n     }\n\n     async fn start(&self, _callback: fn(T)) -> Result<(), Error> {\n         info!(\"Starting exchange adapter for {}\", self.get_api_url());\n         // Base implementation just logs - specific adapters will override this\n         Ok(())\n     }\n\n     async fn stop(&self) -> Result<(), Error> {\n         info!(\"Stopping exchange adapter for {}\", self.get_api_url());\n         // Base implementation just logs - specific adapters will override this\n         Ok(())\n     }\n\n     fn get_sink_topics(&self) -> Vec<String> {\n         self.sink_topics.clone()\n     }\n}\n\n impl<T: Send + Sync + Debug> ExchangeAdapter<T> for ExchangeAdapterImpl {\n     fn get_api_url(&self) -> String {\n         self.api_url.clone()\n     }\n\n     fn get_pairs(&self) -> Vec<String> {\n         self.pairs.clone()\n     }\n\n     fn get_exchange_name(&self) -> ExchangeName {\n         self.exchange_name\n     }\n }\n\n #[cfg(test)]\n mod tests {\n     use super::*;\n\n     #[test]\n     fn test_valid_trading_pair() {\n         assert!(ExchangeAdapterImpl::is_valid_trading_pair(\"BTC-USD\"));\n         assert!(ExchangeAdapterImpl::is_valid_trading_pair(\"ETH-EUR\"));\n\n         // Invalid cases\n         assert!(!ExchangeAdapterImpl::is_valid_trading_pair(\"\"));\n         assert!(!ExchangeAdapterImpl::is_valid_trading_pair(\"BTC\"));\n         assert!(!ExchangeAdapterImpl::is_valid_trading_pair(\"BTC-\"));\n         assert!(!ExchangeAdapterImpl::is_valid_trading_pair(\"-USD\"));\n         assert!(!ExchangeAdapterImpl::is_valid_trading_pair(\"BTC-USD-EUR\"));\n         assert!(!ExchangeAdapterImpl::is_valid_trading_pair(\"BTC123-USD\"));\n     }\n\n     #[test]\n     fn test_exchange_adapter_creation() {\n         let config = ExchangeConfig {\n             api_url: \"wss://example.com\".to_string(),\n             pairs: vec![\"BTC-USD\".to_string()],\n         };\n\n         let adapter = ExchangeAdapterImpl::new(config, ExchangeName::Coinbase);\n         assert!(adapter.is_ok());\n\n         let config_empty_url = ExchangeConfig {\n             api_url: \"\".to_string(),\n             pairs: vec![\"BTC-USD\".to_string()],\n         };\n         assert!(ExchangeAdapterImpl::new(config_empty_url, ExchangeName::Coinbase).is_err());\n\n         let config_empty_pairs = ExchangeConfig {\n             api_url: \"wss://example.com\".to_string(),\n             pairs: vec![],\n         };\n         assert!(ExchangeAdapterImpl::new(config_empty_pairs, ExchangeName::Coinbase).is_err());\n     }\n}\n",
  "src/infra/execution/mod.rs": "pub mod manager;\n",
  "src/infra/execution/manager.rs": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse async_trait::async_trait;\nuse log::{error, info, warn};\nuse tokio::sync::Mutex;\nuse uuid::Uuid;\n\nuse crate::common::types::Error;\nuse crate::domain::events::{TradeSignalEvent, OrderStatusEvent, OrderStatus};\nuse crate::domain::interfaces::BrokerPort;\nuse crate::domain::models::Order;\nuse crate::common::enums::{OrderType, TradeSide};\nconst MAX_ORDER_SIZE: f64 = 10.0;\nconst MIN_ORDER_SIZE: f64 = 0.0001;\n\n/// Manages order execution and broker interactions\n#[derive(Debug)]\npub struct ExecutionManager {\n    broker: Arc<Mutex<Option<Box<dyn BrokerPort<OrderStatusType = OrderStatusEvent, OrderType = Order> + Send + Sync>>>>,\n    active_orders: Arc<Mutex<HashMap<String, Order>>>,\n    is_running: Arc<std::sync::atomic::AtomicBool>,\n}\n\nimpl ExecutionManager {\n    /// Creates a new ExecutionManager instance\n    pub fn new(broker: Box<dyn BrokerPort<OrderStatusType = OrderStatusEvent, OrderType = Order> + Send + Sync>) -> Self {\n        ExecutionManager {\n            broker: Arc::new(Mutex::new(Some(broker))),\n            active_orders: Arc::new(Mutex::new(HashMap::new())),\n            is_running: Arc::new(std::sync::atomic::AtomicBool::new(false)),\n        }\n    }\n\n    /// Validates a trade signal\n    fn validate_trade_signal(signal: &TradeSignalEvent) -> Result<(), Error> {\n        if signal.symbol.is_empty() {\n            return Err(Error::ValidationError(\"Symbol cannot be empty\".to_string()));\n        }\n\n        if signal.size <= MIN_ORDER_SIZE {\n            return Err(Error::ValidationError(format!(\"Order size must be greater than {}\", MIN_ORDER_SIZE)));\n        }\n\n        if signal.size > MAX_ORDER_SIZE {\n            return Err(Error::ValidationError(format!(\"Order size cannot exceed {}\", MAX_ORDER_SIZE)));\n        }\n\n         if signal.side != TradeSide::Buy && signal.side != TradeSide::Sell {\n            return Err(Error::ValidationError(\"Invalid order side\".to_string()));\n        }\n\n        Ok(())\n    }\n\n    /// Tracks a new order\n    async fn track_order(&self, order: Order) -> String {\n        let order_id = Uuid::new_v4().to_string();\n        self.active_orders.lock().await.insert(order_id.clone(), order);\n        order_id\n    }\n\n    /// Updates order status\n    async fn update_order_status(&self, order_id: &str, status: &OrderStatusEvent) {\n        let mut orders = self.active_orders.lock().await;\n        if status.status == OrderStatus::Filled || status.status == OrderStatus::Cancelled {\n            orders.remove(order_id);\n        }\n    }\n}\n\nimpl ExecutionManager {\n    /// Handles incoming trade signals\n    pub async fn handle_trade_signal(&self, event: TradeSignalEvent) -> Result<(), Error> {\n       if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Execution manager not running\".to_string()));\n        }\n\n        Self::validate_trade_signal(&event)?;\n\n        let broker_guard = self.broker.lock().await;\n        let broker = broker_guard.as_ref()\n            .ok_or_else(|| Error::OperationError(\"Broker not available\".to_string()))?;\n\n        let order = Order {\n            symbol: event.symbol,\n            side: event.side,\n            size: event.size,\n            price: 0.0,\n            order_type: OrderType::Market,\n        };\n\n        let order_id = self.track_order(order.clone()).await;\n\n        match broker.place_order(order).await {\n            Ok(_) => {\n                info!(\"Order placed successfully: {}\", order_id);\n                Ok(())\n            }\n            Err(e) => {\n                error!(\"Failed to place order {}: {}\", order_id, e);\n                self.active_orders.lock().await.remove(&order_id);\n                Err(e)\n            }\n        }\n    }\n\n    /// Starts the execution manager\n    pub async fn start(&self, callback: fn(OrderStatusEvent)) -> Result<(), Error> {\n         info!(\"Starting execution manager\");\n\n        if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Execution manager already running\".to_string()));\n        }\n\n        let broker_guard = self.broker.lock().await;\n        let broker = broker_guard.as_ref()\n            .ok_or_else(|| Error::OperationError(\"Broker not available\".to_string()))?;\n\n         let active_orders = Arc::clone(&self.active_orders);\n        let wrapped_callback = move |status: OrderStatusEvent| {\n          if !status.order_id.is_empty() {\n            tokio::spawn(async move {\n               active_orders.lock().await.remove(&status.order_id);\n            });\n          }\n         callback(status);\n      };\n         broker.start(wrapped_callback).await?;\n        self.is_running.store(true, std::sync::atomic::Ordering::SeqCst);\n\n        Ok(())\n    }\n\n    /// Stops the execution manager\n    pub async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping execution manager\");\n\n        if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Ok(());\n        }\n\n        let broker_guard = self.broker.lock().await;\n        if let Some(broker) = broker_guard.as_ref() {\n            broker.stop().await?;\n        }\n\n        self.is_running.store(false, std::sync::atomic::Ordering::SeqCst);\n\n         let active_orders = self.active_orders.lock().await.len();\n          if active_orders > 0 {\n              warn!(\"{} orders still active during shutdown\", active_orders);\n           }\n\n        Ok(())\n    }\n\n    /// Gets the count of active orders\n    pub async fn get_active_orders_count(&self) -> usize {\n        self.active_orders.lock().await.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_trade_signal() {\n        // Valid signal\n        let valid_signal = TradeSignalEvent {\n            symbol: \"BTC-USD\".to_string(),\n            side: TradeSide::Buy,\n            size: 1.0,\n            strategy: crate::common::enums::StrategyName::Arbitrage\n        };\n        assert!(ExecutionManager::validate_trade_signal(&valid_signal).is_ok());\n\n        // Invalid size\n        let invalid_size = TradeSignalEvent {\n            symbol: \"BTC-USD\".to_string(),\n             side: TradeSide::Buy,\n            size: 0.0,\n             strategy: crate::common::enums::StrategyName::Arbitrage\n        };\n        assert!(ExecutionManager::validate_trade_signal(&invalid_size).is_err());\n\n        // Invalid side\n        let invalid_side = TradeSignalEvent {\n            symbol: \"BTC-USD\".to_string(),\n            side: TradeSide::Buy,\n            size: 1.0,\n             strategy: crate::common::enums::StrategyName::Arbitrage\n        };\n        assert!(ExecutionManager::validate_trade_signal(&invalid_side).is_ok());\n         let invalid_side = TradeSignalEvent {\n            symbol: \"BTC-USD\".to_string(),\n            side:  TradeSide::Sell,\n            size: 1.0,\n             strategy: crate::common::enums::StrategyName::Arbitrage\n        };\n          assert!(ExecutionManager::validate_trade_signal(&invalid_side).is_ok());\n          let invalid_side = TradeSignalEvent {\n            symbol: \"BTC-USD\".to_string(),\n             side:  TradeSide::Buy,\n            size: 1.0,\n             strategy: crate::common::enums::StrategyName::Arbitrage\n        };\n         assert!(ExecutionManager::validate_trade_signal(&invalid_side).is_ok());\n    }\n}\n",
  "src/infra/event_bus/mod.rs": "pub mod zmq;\n",
  "src/infra/event_bus/zmq.rs": "use std::sync::Arc;\nuse std::time::Duration;\nuse async_trait::async_trait;\nuse log::{error, info, warn};\nuse tokio::sync::Mutex;\nuse zmq::{Context, Socket, SocketType};\n\nuse crate::common::types::Error;\nuse crate::domain::events::DomainEvent;\nuse crate::domain::interfaces::EventBusPort;\n\nconst SOCKET_TIMEOUT_MS: i32 = 5000;\nconst MAX_RECONNECT_ATTEMPTS: u32 = 3;\n\n/// ZMQ implementation of the event bus\n#[derive(Debug)]\npub struct ZMQEventBus {\n    address: String,\n    context: Arc<Context>,\n    publisher: Arc<Mutex<Option<Socket>>>,\n    subscriber: Arc<Mutex<Option<Socket>>>,\n    router: Arc<Mutex<Option<Socket>>>,\n    dealer: Arc<Mutex<Option<Socket>>>,\n    is_running: Arc<std::sync::atomic::AtomicBool>,\n}\n\n#[derive(Debug)]\nstruct SocketConfig {\n    socket_type: SocketType,\n    timeout_ms: i32,\n    is_server: bool,\n}\n\nimpl ZMQEventBus {\n    /// Creates a new ZMQEventBus instance\n    pub fn new(address: String) -> Result<Self, Error> {\n        if address.is_empty() {\n            return Err(Error::ValidationError(\"Address cannot be empty\".to_string()));\n        }\n\n        if !address.starts_with(\"tcp://\") && !address.starts_with(\"ipc://\") {\n            return Err(Error::ValidationError(\"Invalid address format\".to_string()));\n        }\n\n        Ok(ZMQEventBus {\n            address,\n            context: Arc::new(Context::new()),\n            publisher: Arc::new(Mutex::new(None)),\n            subscriber: Arc::new(Mutex::new(None)),\n            router: Arc::new(Mutex::new(None)),\n            dealer: Arc::new(Mutex::new(None)),\n            is_running: Arc::new(std::sync::atomic::AtomicBool::new(true)),\n        })\n    }\n\n    /// Validates a topic string\n    fn validate_topic(topic: &str) -> Result<(), Error> {\n        if topic.is_empty() {\n            return Err(Error::ValidationError(\"Topic cannot be empty\".to_string()));\n        }\n        if topic.contains(' ') {\n            return Err(Error::ValidationError(\"Topic cannot contain spaces\".to_string()));\n        }\n        Ok(())\n    }\n\n    /// Creates a new socket of the specified type\n    fn create_socket(&self, socket_type: SocketType) -> Result<Socket, Error> {\n        let socket = self.context.socket(socket_type)\n            .map_err(|e| Error::ConnectionError(format!(\"Failed to create socket: {}\", e)))?;\n        Ok(socket)\n    }\n\n    /// Configures a socket with given parameters\n    fn configure_socket(socket: &Socket, config: &SocketConfig) -> Result<(), Error> {\n        socket.set_rcvtimeo(config.timeout_ms)\n            .map_err(|e| Error::ConfigError(format!(\"Failed to set receive timeout: {}\", e)))?;\n\n        socket.set_sndtimeo(config.timeout_ms)\n            .map_err(|e| Error::ConfigError(format!(\"Failed to set send timeout: {}\", e)))?;\n\n        Ok(())\n    }\n\n    async fn get_socket(&self, config: SocketConfig) -> Result<Socket, Error> {\n        let socket_mutex = match config.socket_type {\n            SocketType::PUB => &self.publisher,\n            SocketType::SUB => &self.subscriber,\n            SocketType::ROUTER => &self.router,\n            SocketType::DEALER => &self.dealer,\n            _ => return Err(Error::ConfigError(\"Unsupported socket type\".to_string())),\n        };\n\n        let socket_guard = socket_mutex.lock().await;\n        if let Some(socket) = &*socket_guard {\n            return Ok(socket.get_context()\n                .map_err(|e| Error::ConnectionError(e.to_string()))?\n                .socket(socket.get_socket_type().map_err(|e| Error::ConnectionError(e.to_string()))?)\n                .map_err(|e| Error::ConnectionError(e.to_string()))?);\n        }\n        drop(socket_guard);\n\n        let mut socket_guard = socket_mutex.lock().await;\n        let socket = self.create_socket(config.socket_type)?;\n        Self::configure_socket(&socket, &config)?;\n\n        if config.is_server {\n            socket.bind(&self.address)\n                .map_err(|e| Error::ConnectionError(format!(\"Failed to bind socket: {}\", e)))?;\n        } else {\n            socket.connect(&self.address)\n                .map_err(|e| Error::ConnectionError(format!(\"Failed to connect socket: {}\", e)))?;\n        }\n\n        let new_socket = socket.get_context()\n            .map_err(|e| Error::ConnectionError(e.to_string()))?\n            .socket(socket.get_socket_type().map_err(|e| Error::ConnectionError(e.to_string()))?)\n            .map_err(|e| Error::ConnectionError(e.to_string()))?;\n\n        *socket_guard = Some(socket);\n        info!(\"{:?} socket initialized\", config.socket_type);\n\n        Self::configure_socket(&new_socket, &config)?;\n        if config.is_server {\n            new_socket.bind(&self.address)\n                .map_err(|e| Error::ConnectionError(format!(\"Failed to bind new socket: {}\", e)))?;\n        } else {\n            new_socket.connect(&self.address)\n                .map_err(|e| Error::ConnectionError(format!(\"Failed to connect new socket: {}\", e)))?;\n        }\n\n        Ok(new_socket)\n    }\n\n    async fn get_publisher(&self) -> Result<Socket, Error> {\n        self.get_socket(SocketConfig {\n            socket_type: SocketType::PUB,\n            timeout_ms: SOCKET_TIMEOUT_MS,\n            is_server: true,\n        }).await\n    }\n\n    async fn get_subscriber(&self) -> Result<Socket, Error> {\n        self.get_socket(SocketConfig {\n            socket_type: SocketType::SUB,\n            timeout_ms: SOCKET_TIMEOUT_MS,\n            is_server: false,\n        }).await\n    }\n\n    /// Attempts to reconnect a socket with retries\n    async fn try_reconnect(&self, socket: &Socket) -> Result<(), Error> {\n        for attempt in 1..=MAX_RECONNECT_ATTEMPTS {\n            match socket.connect(&self.address) {\n                Ok(_) => {\n                    info!(\"Successfully reconnected on attempt {}\", attempt);\n                    return Ok(());\n                }\n                Err(e) => {\n                    if attempt == MAX_RECONNECT_ATTEMPTS {\n                        return Err(Error::ConnectionError(format!(\"Failed to reconnect: {}\", e)));\n                    }\n                    warn!(\"Reconnect attempt {} failed, retrying...\", attempt);\n                    tokio::time::sleep(Duration::from_secs(1)).await;\n                }\n            }\n        }\n        Err(Error::ConnectionError(\"Max reconnection attempts reached\".to_string()))\n    }\n}\n\n#[async_trait]\nimpl EventBusPort for ZMQEventBus {\n    type EventType = DomainEvent;\n\n    async fn publish(&self, event: Self::EventType, topic: String) -> Result<(), Error> {\n        Self::validate_topic(&topic)?;\n\n        let publisher = self.get_publisher().await?;\n        let data = serde_json::to_string(&event)\n            .map_err(|e| Error::SerializationError(format!(\"Failed to serialize event: {}\", e)))?;\n\n        let message = format!(\"{} {}\", topic, data);\n\n        match publisher.send(message.as_bytes(), 0) {\n            Ok(_) => {\n                info!(\"Published event to topic {}: {:?}\", topic, event);\n                Ok(())\n            }\n            Err(e) => {\n                error!(\"Failed to publish event to topic {}: {}\", topic, e);\n                // Attempt to reconnect and retry once\n                if let Ok(_) = self.try_reconnect(&publisher).await {\n                    publisher.send(message.as_bytes(), 0)\n                        .map_err(|e| Error::PublishError(format!(\"Failed to publish event after reconnect: {}\", e)))?;\n                    Ok(())\n                } else {\n                    Err(Error::PublishError(\"Failed to publish event\".to_string()))\n                }\n            }\n        }\n    }\n\n    async fn subscribe<F>(&self, topic: String, mut callback: F) -> Result<(), Error>\n    where\n        F: FnMut(Self::EventType) + Send + 'static,\n    {\n        Self::validate_topic(&topic)?;\n\n        let subscriber = self.get_subscriber().await?;\n        subscriber.set_subscribe(topic.as_bytes())\n            .map_err(|e| Error::SubscriptionError(format!(\"Failed to subscribe to topic {}: {}\", topic, e)))?;\n\n        info!(\"Subscribed to topic {}\", topic);\n\n        let is_running = Arc::clone(&self.is_running);\n        let topic_clone = topic.clone();\n\n        tokio::spawn(async move {\n            while is_running.load(std::sync::atomic::Ordering::SeqCst) {\n                match subscriber.recv_msg(0) {\n                    Ok(msg) => {\n                        match String::from_utf8(msg.to_vec()) {\n                            Ok(message) => {\n                                let parts: Vec<&str> = message.splitn(2, ' ').collect();\n                                if parts.len() == 2 && parts[0] == topic_clone {\n                                    match serde_json::from_str::<DomainEvent>(parts[1]) {\n                                        Ok(event) => callback(event),\n                                        Err(e) => error!(\"Failed to deserialize message: {}\", e),\n                                    }\n                                }\n                            }\n                            Err(e) => error!(\"Invalid UTF-8 in message: {}\", e),\n                        }\n                    }\n                    Err(e) => {\n                        error!(\"Error receiving message on topic {}: {}\", topic_clone, e);\n                        tokio::time::sleep(Duration::from_secs(1)).await;\n                    }\n                }\n            }\n            info!(\"Subscription loop ended for topic {}\", topic_clone);\n        });\n\n        Ok(())\n    }\n\n    async fn subscribe_many<F>(&self, topics: Vec<String>, callback: F) -> Result<(), Error>\n    where\n        F: FnMut(Self::EventType) + Send + 'static + Clone,\n    {\n        if topics.is_empty() {\n            return Err(Error::ValidationError(\"Topics list cannot be empty\".to_string()));\n        }\n\n        for topic in topics {\n            self.subscribe(topic, callback.clone()).await?;\n        }\n        Ok(())\n    }\n\n    async fn shutdown(&self) -> Result<(), Error> {\n        self.is_running.store(false, std::sync::atomic::Ordering::SeqCst);\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration;\n    use tokio::time::sleep;\n\n    #[test]\n    fn test_zmq_event_bus_creation() {\n        let valid_address = \"tcp://127.0.0.1:5555\".to_string();\n        assert!(ZMQEventBus::new(valid_address).is_ok());\n\n        let empty_address = \"\".to_string();\n        assert!(ZMQEventBus::new(empty_address).is_err());\n\n        let invalid_address = \"invalid://address\".to_string();\n        assert!(ZMQEventBus::new(invalid_address).is_err());\n    }\n\n    #[test]\n    fn test_topic_validation() {\n        assert!(ZMQEventBus::validate_topic(\"valid.topic\").is_ok());\n        assert!(ZMQEventBus::validate_topic(\"\").is_err());\n        assert!(ZMQEventBus::validate_topic(\"invalid topic\").is_err());\n    }\n\n    #[tokio::test]\n    async fn test_publish_subscribe() {\n        let event_bus = ZMQEventBus::new(\"tcp://127.0.0.1:5556\".to_string()).unwrap();\n        let topic = \"test.topic\".to_string();\n        \n        let mut received = false;\n        event_bus.subscribe(topic.clone(), move |_event| {\n            received = true;\n        }).await.unwrap();\n\n        // Give some time for the subscription to be established\n        sleep(Duration::from_millis(100)).await;\n\n        // Create a test event\n        let event = DomainEvent::UserInput(crate::domain::events::UserInputEvent {\n            action: \"test\".to_string(),\n            value: None,\n        });\n\n        event_bus.publish(event, topic).await.unwrap();\n\n        // Wait for the message to be processed\n        sleep(Duration::from_millis(100)).await;\n\n        assert!(received);\n    }\n}\n",
  "src/infra/broker_adapters/mod.rs": "pub mod interactive_broker_adapter;\npub mod base;\n",
  "src/infra/broker_adapters/interactive_broker_adapter.rs": "use std::sync::Arc;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse async_trait::async_trait;\nuse log::{error, info};\nuse tokio::sync::Mutex;\nuse tokio::time::{sleep, Duration};\nuse uuid::Uuid;\n\nuse crate::common::types::Error;\nuse crate::config::BrokerConfig;\nuse crate::domain::events::{OrderStatusEvent, OrderStatus};\nuse crate::domain::interfaces::BrokerPort;\nuse crate::domain::models::Order;\nuse crate::infra::broker_adapters::base::{BaseBrokerAdapter, BrokerAdapterImpl};\nuse crate::common::enums::OrderType;\n\n/// Interactive Broker adapter implementation\n#[derive(Debug)]\npub struct InteractiveBrokerAdapter {\n    base: BrokerAdapterImpl,\n    callback: Arc<Mutex<Option<Box<dyn FnMut(OrderStatusEvent) + Send + 'static>>>>,\n    is_running: Arc<AtomicBool>,\n}\n\nimpl InteractiveBrokerAdapter {\n    /// Creates a new InteractiveBrokerAdapter instance\n    pub fn new(config: BrokerConfig) -> Result<Self, Error> {\n        Ok(InteractiveBrokerAdapter {\n            base: BrokerAdapterImpl::new(config)?,\n            callback: Arc::new(Mutex::new(None)),\n            is_running: Arc::new(AtomicBool::new(false)),\n        })\n    }\n\n    /// Validates an order before submission\n    fn validate_order(order: &Order) -> Result<(), Error> {\n        if order.size <= 0.0 {\n            return Err(Error::ValidationError(\"Order size must be positive\".to_string()));\n        }\n        if let OrderType::Limit = order.order_type {\n            if order.price <= 0.0 {\n                return Err(Error::ValidationError(\"Limit price must be positive\".to_string()));\n            }\n        }\n        if order.symbol.is_empty() {\n            return Err(Error::ValidationError(\"Symbol cannot be empty\".to_string()));\n        }\n        Ok(())\n    }\n\n    async fn notify_status(&self, event: OrderStatusEvent) {\n        if let Some(mut callback) = self.callback.lock().await.as_mut() {\n            callback(event);\n        }\n    }\n}\n\n#[async_trait]\nimpl BrokerPort for InteractiveBrokerAdapter {\n    type OrderStatusType = OrderStatusEvent;\n    type OrderType = Order;\n\n    async fn place_order(&self, order: Self::OrderType) -> Result<(), Error> {\n        if !self.is_running.load(Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Broker adapter not started\".to_string()));\n        }\n\n        Self::validate_order(&order)?;\n\n        let order_id = Uuid::new_v4().to_string();\n        info!(\n            \"Placing order {:?} {} of {} (ID: {})\",\n            order.side, order.size, order.symbol, order_id\n        );\n\n        let accepted_event = OrderStatusEvent {\n            order_id: order_id.clone(),\n            status: OrderStatus::New,\n            filled_size: 0.0,\n            remaining_size: order.size,\n            fill_price: 0.0,\n            reason: String::new(),\n        };\n\n        self.notify_status(accepted_event).await;\n\n        // Simulate order fill after delay\n        let self_clone = Arc::new(self.clone());\n        let order_clone = order.clone();\n        tokio::spawn(async move {\n            sleep(Duration::from_secs(2)).await;\n\n            let filled_event = OrderStatusEvent {\n                order_id,\n                status: OrderStatus::Filled,\n                filled_size: order_clone.size,\n                remaining_size: 0.0,\n                fill_price: match order_clone.order_type {\n                    OrderType::Limit => order_clone.price,\n                    _ => 9999.99\n                },\n                reason: String::new(),\n            };\n\n            info!(\"Order filled: {:?}\", filled_event);\n            self_clone.notify_status(filled_event).await;\n        });\n\n        Ok(())\n    }\n\n    async fn get_order_status(&self) -> Result<Option<OrderStatusEvent>, Error> {\n        if !self.is_running.load(Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Broker adapter not started\".to_string()));\n        }\n        // Mock implementation - could be extended to track actual orders\n        Ok(None)\n    }\n\n    async fn start<F>(&self, callback: F) -> Result<(), Error>\n    where\n        F: FnMut(OrderStatusEvent) + Send + 'static,\n    {\n        info!(\"Starting Interactive Broker adapter\");\n        self.is_running.store(true, Ordering::SeqCst);\n        *self.callback.lock().await = Some(Box::new(callback));\n        Ok(())\n    }\n\n    async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping Interactive Broker adapter\");\n        self.is_running.store(false, Ordering::SeqCst);\n        *self.callback.lock().await = None;\n        Ok(())\n    }\n\n    fn get_sink_topics(&self) -> Vec<String> {\n        self.base.get_sink_topics()\n    }\n}\n\nimpl BaseBrokerAdapter for InteractiveBrokerAdapter {\n    type OrderType = Order;\n    type OrderStatusType = OrderStatusEvent;\n\n    fn get_broker_api(&self) -> String {\n        self.base.get_broker_api()\n    }\n}\n\n// Add Clone implementation to support Arc\nimpl Clone for InteractiveBrokerAdapter {\n    fn clone(&self) -> Self {\n        Self {\n            base: self.base.clone(),\n            callback: Arc::clone(&self.callback),\n            is_running: Arc::clone(&self.is_running),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::common::enums::TradeSide;\n\n    #[test]\n    fn test_adapter_creation() {\n        let config = BrokerConfig {\n            host: \"api.interactivebrokers.com\".to_string(),\n            port: 8080,\n            client_id: 1,\n            account_id: \"\".to_string(),\n            paper_trading: false,\n            max_retries: 3,\n            timeout: 5000\n        };\n        let adapter = InteractiveBrokerAdapter::new(config);\n        assert!(adapter.is_ok());\n    }\n\n    #[test]\n    fn test_order_validation() {\n        // Valid order\n        let valid_order = Order {\n            symbol: \"BTC-USD\".to_string(),\n            size: 1.0,\n            side: TradeSide::Buy,\n            order_type: OrderType::Limit,\n            price: 50000.0,\n        };\n        assert!(InteractiveBrokerAdapter::validate_order(&valid_order).is_ok());\n\n        // Invalid size\n        let invalid_size = Order {\n            symbol: \"BTC-USD\".to_string(),\n            size: 0.0,\n            side: TradeSide::Buy,\n            order_type: OrderType::Limit,\n            price: 50000.0,\n        };\n        assert!(InteractiveBrokerAdapter::validate_order(&invalid_size).is_err());\n\n        // Invalid price\n        let invalid_price = Order {\n            symbol: \"BTC-USD\".to_string(),\n            size: 1.0,\n            side: TradeSide::Buy,\n            order_type: OrderType::Limit,\n            price: 0.0,\n        };\n        assert!(InteractiveBrokerAdapter::validate_order(&invalid_price).is_err());\n    }\n}\n",
  "src/infra/broker_adapters/base.rs": "use std::fmt::Debug;\nuse async_trait::async_trait;\nuse log::info;\n\nuse crate::common::types::Error;\nuse crate::config::BrokerConfig;\nuse crate::domain::interfaces::BrokerPort;\nuse crate::domain::models::Order;\nuse crate::domain::events::OrderStatusEvent;\n\n/// Base trait for broker adapters that defines common functionality\n#[async_trait]\npub trait BaseBrokerAdapter: Send + Sync + Debug {\n    type OrderType: Send + Sync + Debug;\n    type OrderStatusType: Send + Sync + Debug;\n\n    /// Returns the broker API endpoint\n    fn get_broker_api(&self) -> String;\n\n    /// Validates the broker configuration\n    fn validate_config(config: &BrokerConfig) -> Result<(), Error> {\n        if config.host.is_empty() {\n            return Err(Error::ValidationError(\"Broker host cannot be empty\".to_string()));\n        }\n        if config.port == 0 {\n            return Err(Error::ValidationError(\"Broker port cannot be zero\".to_string()));\n        }\n        Ok(())\n    }\n}\n\n/// Base implementation for broker adapters\n#[derive(Debug, Clone)]\npub struct BrokerAdapterImpl {\n    broker_api: String,\n    sink_topics: Vec<String>\n}\n\nimpl BrokerAdapterImpl {\n    /// Creates a new BrokerAdapterImpl instance\n    pub fn new(config: BrokerConfig) -> Result<Self, Error> {\n        Self::validate_config(&config)?;\n\n        Ok(Self {\n            broker_api: format!(\n                \"{}://{}:{}\", \n                if config.paper_trading { \"https\" } else { \"http\" }, \n                config.host, \n                config.port\n            ),\n            sink_topics: vec![]\n        })\n    }\n\n    pub fn get_sink_topics(&self) -> Vec<String> {\n        self.sink_topics.clone()\n    }\n}\n\n#[async_trait]\nimpl BrokerPort for BrokerAdapterImpl {\n    type OrderType = Order;\n    type OrderStatusType = OrderStatusEvent;\n\n    async fn place_order(&self, _order: Self::OrderType) -> Result<(), Error> {\n        info!(\"Base implementation - place_order not implemented\");\n        Ok(())\n    }\n\n    async fn get_order_status(&self) -> Result<Option<Self::OrderStatusType>, Error> {\n        info!(\"Base implementation - get_order_status not implemented\");\n        Ok(None)\n    }\n\n    async fn start<F>(&self, _callback: F) -> Result<(), Error>\n    where\n        F: FnMut(Self::OrderStatusType) + Send + 'static,\n    {\n        info!(\"Starting broker adapter for {}\", self.broker_api);\n        Ok(())\n    }\n\n    async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping broker adapter for {}\", self.broker_api);\n        Ok(())\n    }\n\n    fn get_sink_topics(&self) -> Vec<String> {\n        self.sink_topics.clone()\n    }\n}\n\nimpl BaseBrokerAdapter for BrokerAdapterImpl {\n    type OrderType = Order;\n    type OrderStatusType = OrderStatusEvent;\n\n    fn get_broker_api(&self) -> String {\n        self.broker_api.clone()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_broker_adapter_creation() {\n        // Valid configuration\n        let config = BrokerConfig {\n            host: \"api.broker.com\".to_string(),\n            port: 8080,\n            client_id: 1,\n            account_id: \"\".to_string(),\n            paper_trading: false,\n            max_retries: 3,\n            timeout: 5000\n        };\n        let adapter = BrokerAdapterImpl::new(config);\n        assert!(adapter.is_ok());\n\n        // Invalid configuration - empty host\n        let config = BrokerConfig {\n            host: \"\".to_string(),\n            port: 0,\n            client_id: 1,\n            account_id: \"\".to_string(),\n            paper_trading: false,\n            max_retries: 3,\n            timeout: 5000\n        };\n        let adapter = BrokerAdapterImpl::new(config);\n        assert!(adapter.is_err());\n\n        // Invalid configuration - zero port\n        let config = BrokerConfig {\n            host: \"invalid-url\".to_string(),\n            port: 0,\n            client_id: 1,\n            account_id: \"\".to_string(),\n            paper_trading: false,\n            max_retries: 3,\n            timeout: 5000\n        };\n        let adapter = BrokerAdapterImpl::new(config);\n        assert!(adapter.is_err());\n    }\n\n    #[test]\n    fn test_broker_api_getter() {\n        let config = BrokerConfig {\n            host: \"api.broker.com\".to_string(),\n            port: 8080,\n            client_id: 1,\n            account_id: \"\".to_string(),\n            paper_trading: false,\n            max_retries: 3,\n            timeout: 5000\n        };\n        let adapter = BrokerAdapterImpl::new(config).unwrap();\n        assert_eq!(adapter.get_broker_api(), \"http://api.broker.com:8080\");\n    }\n}\n",
  "src/domain/mod.rs": "pub mod events;\npub mod interfaces;\npub mod models;\npub mod strategies;\n",
  "src/domain/interfaces.rs": "use async_trait::async_trait;\nuse std::fmt::Debug;\nuse crate::common::types::Error;\nuse crate::domain::models::StrategyConfig;\n\n/// Event bus interface for publishing and subscribing to events\n#[async_trait]\npub trait EventBusPort: Send + Sync + Debug {\n    type EventType: Send + Sync + Debug;\n\n    async fn publish(&self, event: Self::EventType, topic: String) -> Result<(), Error>;\n    \n    // Change these to accept boxed closures instead of fn pointers\n    async fn subscribe<F>(&self, topic: String, callback: F) -> Result<(), Error>\n    where\n        F: FnMut(Self::EventType) + Send + 'static;\n    \n    async fn subscribe_many<F>(&self, topics: Vec<String>, callback: F) -> Result<(), Error>\n    where\n        F: FnMut(Self::EventType) + Send + 'static;\n\n    async fn shutdown(&self) -> Result<(), Error>;\n}\n\n/// Data adapter interface for connecting to and processing data from external sources\n#[async_trait]\npub trait DataAdapterPort<T>: Send + Sync + Debug {\n    async fn connect(&self) -> Result<(), Error>;\n    async fn process_message(&self) -> Result<Option<T>, Error>;\n    async fn start<F>(&self, callback: F) -> Result<(), Error>\n    where\n        F: FnMut(T) + Send + 'static;\n    async fn stop(&self) -> Result<(), Error>;\n    fn get_sink_topics(&self) -> Vec<String>;\n}\n\n/// Trading strategy interface for analyzing market data and generating signals\n#[async_trait]\npub trait StrategyPort: Send + Sync + Debug {\n    type EventType: Send + Sync + Debug;\n    type TradeSignalType: Send + Sync + Debug;\n\n    async fn analyze_market_data(&self, event: Self::EventType) -> Result<Vec<Self::TradeSignalType>, Error>;\n    async fn start<F>(&self, callback: F) -> Result<(), Error>\n    where\n        F: FnMut(Self::TradeSignalType) + Send + 'static;\n    async fn stop(&self) -> Result<(), Error>;\n    async fn configure_strategy(&mut self, config: StrategyConfig) -> Result<(), Error>;\n    async fn get_strategy_config(&self) -> Result<StrategyConfig, Error>;\n    fn get_sink_topics(&self) -> Vec<String>;\n    fn get_source_topics(&self) -> Vec<String>;\n}\n\n/// Broker interface for placing orders and managing order status\n#[async_trait]\npub trait BrokerPort: Send + Sync + Debug {\n    type OrderStatusType: Send + Sync + Debug;\n    type OrderType: Send + Sync + Debug;\n\n    /// Places a new order with the broker\n    async fn place_order(&self, order: Self::OrderType) -> Result<(), Error>;\n\n    /// Retrieves the current status of an order\n    async fn get_order_status(&self) -> Result<Option<Self::OrderStatusType>, Error>;\n\n    /// Starts the broker connection with status callback\n    async fn start(&self, callback: fn(Self::OrderStatusType)) -> Result<(), Error>;\n\n    /// Stops the broker connection\n    async fn stop(&self) -> Result<(), Error>;\n    /// Returns the list of sink topics\n    fn get_sink_topics(&self) -> Vec<String>;\n}\n\n/// Persistence interface for storing and retrieving data\n#[async_trait]\npub trait PersistenceManager: Send + Sync + Debug {\n    /// Saves data with the specified key\n    async fn save_data(&self, key: String, data: String) -> Result<(), Error>;\n\n    /// Retrieves data for the specified key\n    async fn get_data(&self, key: String) -> Result<Option<String>, Error>;\n}\n\n/// Security interface for authentication, authorization and encryption\n#[async_trait]\npub trait SecurityLayer: Send + Sync + Debug {\n    /// Authenticates a user\n    async fn auth_user(&self, user: String) -> Result<bool, Error>;\n\n    /// Authorizes a user for a specific action\n    async fn authorize_user(&self, user: String, action: String) -> Result<bool, Error>;\n\n    /// Encrypts the provided data\n    async fn encrypt(&self, data: String) -> Result<String, Error>;\n\n    /// Starts the security layer\n    async fn start(&self) -> Result<(), Error>;\n\n    /// Stops the security layer\n    async fn stop(&self) -> Result<(), Error>;\n}\n\n/// Generic subscriber interface for handling events\n#[async_trait]\npub trait Subscriber<T: Send + Sync + Debug>: Send + Sync + Debug {\n    /// Handles an incoming event\n    async fn on_event(&self, event: T);\n\n    /// Subscribes to events with a callback\n    async fn subscribe(&self, callback: fn(T)) -> Result<(), Error>;\n\n    /// Returns the list of source topics\n    fn get_source_topics(&self) -> Vec<String>;\n\n     /// Starts the subscriber\n    async fn start(&self) -> Result<(), Error>;\n\n    /// Stops the subscriber\n    async fn stop(&self) -> Result<(), Error>;\n}\n",
  "src/domain/events.rs": "use serde::{Deserialize, Serialize};\nuse crate::common::enums::{ExchangeName, StrategyName, TradeSide};\n\n/// Represents the status of an order\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum OrderStatus {\n    New,\n    PartiallyFilled,\n    Filled,\n    Cancelled,\n    Rejected,\n}\n\n/// Market data from a specific exchange\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ExchangeData {\n    pub exchange: ExchangeName,\n    pub pair: String,\n    pub price: f64,\n}\n\n/// Event containing price updates from multiple exchanges\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct PriceUpdateEvent {\n    pub kraken_data: Option<ExchangeData>,\n    pub coinbase_data: Option<ExchangeData>,\n}\n\n/// Trading signal generated by a strategy\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct TradeSignalEvent {\n    pub symbol: String,\n    pub side: TradeSide,\n    pub size: f64,\n    pub strategy: StrategyName,\n}\n\n/// Status update for an order\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct OrderStatusEvent {\n    pub order_id: String,\n    pub status: OrderStatus,\n    pub filled_size: f64,\n    pub remaining_size: f64,\n    pub fill_price: f64,\n    pub reason: String,\n}\n\n/// User input event\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct UserInputEvent {\n    pub action: String,\n    pub value: Option<String>\n}\n\n/// Domain events that can occur in the trading system\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum DomainEvent {\n    PriceUpdate(PriceUpdateEvent),\n    TradeSignal(TradeSignalEvent),\n    OrderStatus(OrderStatusEvent),\n    UserInput(UserInputEvent)\n}\n",
  "src/domain/models.rs": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse rust_decimal::Decimal;\nuse crate::common::enums::{StrategyName, TradeSide, OrderType};\n\n/// Represents a trading order\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Order {\n    pub symbol: String,\n    pub side: TradeSide,\n    #[serde(with = \"rust_decimal::serde::float\")]\n    pub size: f64,\n    #[serde(with = \"rust_decimal::serde::float\")]\n    pub price: f64,\n    pub order_type: OrderType,\n}\n\n/// Configuration for a trading strategy\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct StrategyConfig {\n    pub strategy_name: StrategyName,\n    pub params: HashMap<String, String>,\n    pub enabled: bool,\n}\n\nimpl Order {\n    /// Creates a new order with validation\n    pub fn new(\n        symbol: String,\n        side: TradeSide,\n        size: f64,\n        price: f64,\n        order_type: OrderType,\n    ) -> Result<Self, &'static str> {\n        if symbol.is_empty() {\n            return Err(\"Symbol cannot be empty\");\n        }\n        if size <= 0.0 {\n            return Err(\"Size must be positive\");\n        }\n        if price < 0.0 {\n            return Err(\"Price cannot be negative\");\n        }\n\n        Ok(Self {\n            symbol,\n            side,\n            size,\n            price,\n            order_type,\n        })\n    }\n\n    /// Creates a new market buy order\n    pub fn market_buy(symbol: String, size: f64) -> Result<Self, &'static str> {\n        Self::new(symbol, TradeSide::Buy, size, 0.0, OrderType::Market)\n    }\n\n    /// Creates a new market sell order\n    pub fn market_sell(symbol: String, size: f64) -> Result<Self, &'static str> {\n        Self::new(symbol, TradeSide::Sell, size, 0.0, OrderType::Market)\n    }\n\n    /// Creates a new limit buy order\n    pub fn limit_buy(symbol: String, size: f64, price: f64) -> Result<Self, &'static str> {\n        Self::new(symbol, TradeSide::Buy, size, price, OrderType::Limit)\n    }\n\n    /// Creates a new limit sell order\n    pub fn limit_sell(symbol: String, size: f64, price: f64) -> Result<Self, &'static str> {\n        Self::new(symbol, TradeSide::Sell, size, price, OrderType::Limit)\n    }\n}\n\nimpl StrategyConfig {\n    /// Creates a new strategy configuration\n   pub fn new(strategy_name: StrategyName, params: HashMap<String, String>, enabled: bool) -> Self {\n        Self {\n            strategy_name,\n            params,\n            enabled,\n        }\n    }\n\n    /// Gets a parameter value as a string\n    pub fn get_param(&self, key: &str) -> Option<&String> {\n        self.params.get(key)\n    }\n\n     /// Gets a parameter value as a float\n    pub fn get_param_as_f64(&self, key: &str) -> Option<f64> {\n        self.params\n            .get(key)\n            .and_then(|v| v.parse::<f64>().ok())\n    }\n\n    /// Gets a parameter value as an integer\n    pub fn get_param_as_i64(&self, key: &str) -> Option<i64> {\n        self.params\n            .get(key)\n            .and_then(|v| v.parse::<i64>().ok())\n    }\n\n    /// Gets a parameter value as a boolean\n    pub fn get_param_as_bool(&self, key: &str) -> Option<bool> {\n        self.params\n            .get(key)\n            .and_then(|v| v.parse::<bool>().ok())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_order_validation() {\n        assert!(Order::market_buy(\"\".to_string(), 1.0).is_err());\n        assert!(Order::market_buy(\"BTC-USD\".to_string(), 0.0).is_err());\n        assert!(Order::market_buy(\"BTC-USD\".to_string(), -1.0).is_err());\n        assert!(Order::limit_buy(\"BTC-USD\".to_string(), 1.0, -1.0).is_err());\n\n        let valid_order = Order::market_buy(\"BTC-USD\".to_string(), 1.0);\n        assert!(valid_order.is_ok());\n    }\n\n    #[test]\n    fn test_strategy_config() {\n        let mut params = HashMap::new();\n        params.insert(\"threshold\".to_string(), \"0.5\".to_string());\n        params.insert(\"enabled\".to_string(), \"true\".to_string());\n\n        let config = StrategyConfig::new(StrategyName::MeanReversion, params, true);\n\n        assert_eq!(config.get_param_as_f64(\"threshold\"), Some(0.5));\n        assert_eq!(config.get_param_as_bool(\"enabled\"), Some(true));\n        assert_eq!(config.get_param_as_f64(\"nonexistent\"), None);\n    }\n}\n",
  "src/domain/strategies/mod.rs": "pub mod arbitrage;\npub mod mean_reversion;\npub mod base;\n",
  "src/domain/strategies/mean_reversion.rs": "use async_trait::async_trait;\nuse crate::common::types::Error;\nuse crate::common::enums::{StrategyName, TradeSide};\nuse crate::domain::events::{DomainEvent, TradeSignalEvent};\nuse crate::domain::interfaces::StrategyPort;\nuse crate::domain::models::StrategyConfig;\nuse crate::domain::strategies::base::{TradingStrategy, TradingStrategyImpl};\n\n/// MeanReversionStrategy implements a mean reversion trading strategy\n/// that generates signals based on price deviations from moving averages\n#[derive(Debug)]\npub struct MeanReversionStrategy {\n    base: TradingStrategyImpl,\n}\n\nimpl MeanReversionStrategy {\n    pub fn new(config: StrategyConfig, sink_topics: Vec<String>) -> Self {\n        MeanReversionStrategy {\n            base: TradingStrategyImpl::new(config, sink_topics),\n        }\n    }\n}\n\n#[async_trait]\nimpl TradingStrategy<DomainEvent> for MeanReversionStrategy {\n    fn name(&self) -> StrategyName {\n        StrategyName::MeanReversion\n    }\n}\n#[async_trait]\nimpl StrategyPort for MeanReversionStrategy {\n    type EventType = DomainEvent;\n    type TradeSignalType = TradeSignalEvent;\n\n    async fn analyze_market_data(&self, event: Self::EventType) -> Result<Vec<Self::TradeSignalType>, Error> {\n        match event {\n            DomainEvent::PriceUpdate(event) => {\n                if let Some(kraken_data) = &event.kraken_data {\n                     Ok(vec![TradeSignalEvent {\n                        symbol: kraken_data.pair.to_string(),\n                        side: TradeSide::Buy,\n                        size: 0.01,\n                        strategy: self.name(),\n                     }])\n                } else {\n                    Ok(vec![])\n                }\n            }\n            _ => Ok(vec![]),\n        }\n    }\n\n    async fn start(&self, callback: fn(Self::TradeSignalType)) -> Result<(), Error> {\n        self.base.start(callback).await\n    }\n\n    async fn stop(&self) -> Result<(), Error> {\n        self.base.stop().await\n    }\n\n    async fn configure_strategy(&mut self, config: StrategyConfig) -> Result<(), Error> {\n        self.base.configure_strategy(config).await\n    }\n\n   async fn get_strategy_config(&self) -> Result<StrategyConfig, Error> {\n       self.base.get_strategy_config().await\n    }\n\n\n    fn get_sink_topics(&self) -> Vec<String> {\n        self.base.get_sink_topics()\n    }\n\n    fn get_source_topics(&self) -> Vec<String> {\n        vec![\"price.feed.kraken\".to_string()]\n    }\n}\n",
  "src/domain/strategies/arbitrage.rs": "use async_trait::async_trait;\nuse crate::common::types::Error;\nuse crate::common::enums::{StrategyName, TradeSide};\nuse crate::domain::events::{DomainEvent, TradeSignalEvent};\nuse crate::domain::interfaces::StrategyPort;\nuse crate::domain::models::StrategyConfig;\nuse crate::domain::strategies::base::{TradingStrategy, TradingStrategyImpl};\n\n/// ArbitrageStrategy implements a basic arbitrage strategy between Kraken and Coinbase\n#[derive(Debug)]\npub struct ArbitrageStrategy {\n    base: TradingStrategyImpl,\n}\n\nimpl ArbitrageStrategy {\n    pub fn new(config: StrategyConfig, sink_topics: Vec<String>) -> Self {\n        ArbitrageStrategy {\n            base: TradingStrategyImpl::new(config, sink_topics),\n        }\n    }\n}\n#[async_trait]\nimpl TradingStrategy<DomainEvent> for ArbitrageStrategy {\n    fn name(&self) -> StrategyName {\n        StrategyName::Arbitrage\n    }\n}\n\n#[async_trait]\nimpl StrategyPort for ArbitrageStrategy {\n    type EventType = DomainEvent;\n    type TradeSignalType = TradeSignalEvent;\n\n    async fn analyze_market_data(&self, event: Self::EventType) -> Result<Vec<Self::TradeSignalType>, Error> {\n        let mut signals = vec![];\n\n        if let DomainEvent::PriceUpdate(price_event) = event {\n            if let (Some(kraken_data), Some(coinbase_data)) = (&price_event.kraken_data, &price_event.coinbase_data) {\n                let kraken_price = kraken_data.price;\n                let coinbase_price = coinbase_data.price;\n                let symbol = &kraken_data.pair;\n\n                 let signal = if kraken_price > coinbase_price {\n                    Some((TradeSide::Buy, 0.01))\n                } else if coinbase_price > kraken_price {\n                    Some((TradeSide::Sell, 0.01))\n                 } else {\n                    None\n                };\n\n                if let Some((side, size)) = signal {\n                    signals.push(TradeSignalEvent {\n                        symbol: symbol.to_string(),\n                        side,\n                        size,\n                        strategy: self.name(),\n                    });\n                }\n            }\n        }\n        Ok(signals)\n    }\n    async fn start(&self, callback: fn(Self::TradeSignalType)) -> Result<(), Error> {\n        self.base.start(callback).await\n    }\n\n    async fn stop(&self) -> Result<(), Error> {\n        self.base.stop().await\n    }\n\n    async fn configure_strategy(&mut self, config: StrategyConfig) -> Result<(), Error> {\n        self.base.configure_strategy(config).await\n    }\n\n   async fn get_strategy_config(&self) -> Result<StrategyConfig, Error> {\n      self.base.get_strategy_config().await\n   }\n\n    fn get_sink_topics(&self) -> Vec<String> {\n        self.base.get_sink_topics()\n    }\n\n    fn get_source_topics(&self) -> Vec<String> {\n       vec![\n           \"price.feed.kraken\".to_string(),\n           \"price.feed.coinbase\".to_string(),\n        ]\n    }\n}\n",
  "src/domain/strategies/base.rs": "use async_trait::async_trait;\nuse std::fmt::Debug;\nuse crate::common::types::Error;\nuse crate::common::enums::StrategyName;\nuse crate::domain::events::{DomainEvent, TradeSignalEvent};\nuse crate::domain::interfaces::StrategyPort;\nuse crate::domain::models::StrategyConfig;\nuse log::info;\n\n/// Defines the core functionality for all trading strategies\n#[async_trait]\npub trait TradingStrategy<T: Send + Sync + Debug>: StrategyPort<EventType = DomainEvent, TradeSignalType = TradeSignalEvent> + Send + Sync {\n    /// Returns the unique name of the trading strategy\n    fn name(&self) -> StrategyName;\n}\n\n/// Base implementation for trading strategies\n#[derive(Debug)]\npub struct TradingStrategyImpl {\n    strategy_config: StrategyConfig,\n    sink_topics: Vec<String>,\n}\n\nimpl TradingStrategyImpl {\n    pub fn new(config: StrategyConfig, sink_topics: Vec<String>) -> Self {\n        TradingStrategyImpl {\n            strategy_config: config,\n            sink_topics,\n        }\n    }\n\n    pub fn get_sink_topics(&self) -> Vec<String> {\n        self.sink_topics.clone()\n    }\n\n    pub fn get_config(&self) -> &StrategyConfig {\n        &self.strategy_config\n    }\n}\n\n#[async_trait]\nimpl StrategyPort for TradingStrategyImpl {\n    type EventType = DomainEvent;\n    type TradeSignalType = TradeSignalEvent;\n\n    async fn analyze_market_data(&self, _event: Self::EventType) -> Result<Vec<Self::TradeSignalType>, Error> {\n        Ok(vec![])\n    }\n\n     async fn start(&self, _callback: fn(Self::TradeSignalType)) -> Result<(), Error> {\n         info!(\"Starting strategy {:?}\", self.strategy_config.strategy_name);\n         Ok(())\n     }\n\n    async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping strategy {:?}\", self.strategy_config.strategy_name);\n        Ok(())\n    }\n\n    async fn configure_strategy(&mut self, config: StrategyConfig) -> Result<(), Error> {\n        info!(\n            \"Configuring strategy {:?} with {:?}\",\n            self.strategy_config.strategy_name,\n            config\n        );\n        self.strategy_config = config;\n        Ok(())\n    }\n\n    async fn get_strategy_config(&self) -> Result<StrategyConfig, Error> {\n      Ok(self.strategy_config.clone())\n    }\n\n    fn get_source_topics(&self) -> Vec<String> {\n        vec![]\n    }\n\n      fn get_sink_topics(&self) -> Vec<String> {\n        self.sink_topics.clone()\n    }\n}\n",
  "src/ui/mod.rs": "pub mod console;\npub mod logger;\npub mod metrics;\npub mod audit;\n",
  "src/ui/metrics.rs": "use std::sync::Arc;\nuse std::collections::HashMap;\nuse async_trait::async_trait;\nuse log::{error, info, warn};\nuse tokio::sync::{mpsc, Mutex};\nuse tokio::time::{sleep, Duration};\n\nuse crate::common::types::Error;\nuse crate::domain::events::DomainEvent;\nuse crate::domain::interfaces::Subscriber;\n\nconst METRICS_CHANNEL_SIZE: usize = 1000;\nconst METRICS_UPDATE_MS: u64 = 100;\nconst METRICS_REPORT_MS: u64 = 5000; // Report every 5 seconds\n\n/// Metrics collector and reporter\n#[derive(Debug)]\npub struct MetricsSubscriber {\n    topics: Vec<String>,\n    callback: Arc<Mutex<Option<fn(DomainEvent)>>>,\n    tx: Arc<Mutex<Option<mpsc::Sender<DomainEvent>>>>,\n    is_running: Arc<std::sync::atomic::AtomicBool>,\n    metrics: Arc<Mutex<MetricsData>>,\n}\n\n#[derive(Debug, Default)]\nstruct MetricsData {\n    event_counts: HashMap<String, u64>,\n    order_counts: HashMap<String, u64>,\n    trade_volume: f64,\n    last_report_time: std::time::Instant,\n}\n\nimpl MetricsSubscriber {\n    /// Creates a new MetricsSubscriber instance\n    pub fn new(topics: Vec<String>) -> Result<Self, Error> {\n        if topics.is_empty() {\n            return Err(Error::ValidationError(\"Topics list cannot be empty\".to_string()));\n        }\n\n        for topic in &topics {\n            if topic.is_empty() {\n                return Err(Error::ValidationError(\"Topic cannot be empty\".to_string()));\n            }\n        }\n\n        Ok(MetricsSubscriber {\n            topics,\n            callback: Arc::new(Mutex::new(None)),\n            tx: Arc::new(Mutex::new(None)),\n            is_running: Arc::new(std::sync::atomic::AtomicBool::new(false)),\n            metrics: Arc::new(Mutex::new(MetricsData::default())),\n        })\n    }\n\n    /// Updates metrics based on an event\n    async fn update_metrics(&self, event: &DomainEvent) {\n        let mut metrics = self.metrics.lock().await;\n\n        // Update event counts\n        let event_type = format!(\"{:?}\", event);\n        *metrics.event_counts.entry(event_type).or_insert(0) += 1;\n\n        // Update specific metrics based on event type\n         match event {\n            DomainEvent::OrderStatus(e) => {\n               *metrics.order_counts.entry(format!(\"{:?}\", e.status)).or_insert(0) += 1;\n            }\n            DomainEvent::TradeSignal(e) => {\n                metrics.trade_volume += e.size;\n            }\n             _ => {}\n        }\n\n         // Report metrics periodically\n         if metrics.last_report_time.elapsed() >= Duration::from_millis(METRICS_REPORT_MS) {\n            self.report_metrics(&metrics).await;\n            metrics.last_report_time = std::time::Instant::now();\n         }\n    }\n\n    /// Reports current metrics\n    async fn report_metrics(&self, metrics: &MetricsData) {\n        info!(\"=== Metrics Report ===\");\n        info!(\"Event Counts:\");\n        for (event_type, count) in &metrics.event_counts {\n            info!(\"  {}: {}\", event_type, count);\n        }\n       info!(\"Order Status Counts:\");\n        for (status, count) in &metrics.order_counts {\n            info!(\"  {}: {}\", status, count);\n        }\n        info!(\"Total Trade Volume: {}\", metrics.trade_volume);\n        info!(\"====================\");\n    }\n\n    /// Processes a single event\n    async fn process_event(&self, event: DomainEvent) -> Result<(), Error> {\n         self.update_metrics(&event).await;\n\n         if let Some(callback) = *self.callback.lock().await {\n           callback(event);\n           Ok(())\n        } else {\n           Err(Error::OperationError(\"Callback not set\".to_string()))\n         }\n     }\n}\n\n#[async_trait]\nimpl Subscriber<DomainEvent> for MetricsSubscriber {\n    /// Handles incoming events\n    async fn on_event(&self, event: DomainEvent) {\n         if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n             warn!(\"Metrics subscriber not running, dropping event\");\n             return;\n         }\n\n        if let Some(tx) = self.tx.lock().await.as_ref() {\n            if let Err(e) = tx.send(event).await {\n                error!(\"Failed to queue event: {}\", e);\n             }\n        }\n    }\n\n    /// Subscribes to events with a callback\n    async fn subscribe(&self, callback: fn(DomainEvent)) -> Result<(), Error> {\n         if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Cannot subscribe while running\".to_string()));\n        }\n\n         let mut cb = self.callback.lock().await;\n          *cb = Some(callback);\n\n       info!(\"Metrics subscriber subscribed with callback\");\n        Ok(())\n    }\n\n    /// Returns the list of topics this subscriber is interested in\n    fn get_source_topics(&self) -> Vec<String> {\n        self.topics.clone()\n    }\n\n    /// Starts the metrics subscriber\n    async fn start(&self) -> Result<(), Error> {\n       info!(\"Starting metrics subscriber\");\n\n       if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Metrics subscriber already running\".to_string()));\n       }\n\n        if self.callback.lock().await.is_none() {\n            return Err(Error::OperationError(\"Callback not set\".to_string()));\n        }\n\n        let (tx, mut rx) = mpsc::channel(METRICS_CHANNEL_SIZE);\n        *self.tx.lock().await = Some(tx);\n\n        self.is_running.store(true, std::sync::atomic::Ordering::SeqCst);\n\n          // Reset metrics\n        let mut metrics = self.metrics.lock().await;\n        *metrics = MetricsData::default();\n         metrics.last_report_time = std::time::Instant::now();\n         drop(metrics);\n         let is_running = Arc::clone(&self.is_running);\n\n        tokio::spawn(async move {\n           while is_running.load(std::sync::atomic::Ordering::SeqCst) {\n                if let Ok(event) = rx.try_recv() {\n                    if let Err(e) = self.process_event(event).await {\n                         error!(\"Failed to process event: {}\", e);\n                     }\n                 }\n               sleep(Duration::from_millis(METRICS_UPDATE_MS)).await;\n              }\n             info!(\"Metrics processing loop stopped\");\n         });\n\n        Ok(())\n    }\n\n    /// Stops the metrics subscriber\n    async fn stop(&self) -> Result<(), Error> {\n         info!(\"Stopping metrics subscriber\");\n\n        if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n           return Ok(());\n       }\n\n        self.is_running.store(false, std::sync::atomic::Ordering::SeqCst);\n\n       // Final metrics report\n        let metrics = self.metrics.lock().await;\n         self.report_metrics(&metrics).await;\n\n        *self.tx.lock().await = None;\n\n         Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_metrics_subscriber_creation() {\n        // Valid topics\n        let topics = vec![\"topic1\".to_string(), \"topic2\".to_string()];\n        assert!(MetricsSubscriber::new(topics).is_ok());\n\n        // Empty topics list\n        let empty_topics: Vec<String> = vec![];\n        assert!(MetricsSubscriber::new(empty_topics).is_err());\n\n        // Topics with empty string\n        let invalid_topics = vec![\"topic1\".to_string(), \"\".to_string()];\n        assert!(MetricsSubscriber::new(invalid_topics).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_metrics_lifecycle() {\n        let topics = vec![\"test\".to_string()];\n        let metrics = MetricsSubscriber::new(topics).unwrap();\n\n        // Should fail without callback\n        assert!(metrics.start().await.is_err());\n\n        // Set callback\n          metrics.subscribe(|_| {}).await.unwrap();\n\n        // Start\n        assert!(metrics.start().await.is_ok());\n\n        // Should fail to subscribe while running\n        assert!(metrics.subscribe(|_| {}).await.is_err());\n\n        // Stop\n        assert!(metrics.stop().await.is_ok());\n    }\n}\n",
  "src/ui/console.rs": "use std::io::{self, BufRead};\nuse std::sync::Arc;\nuse async_trait::async_trait;\nuse log::{error, info, warn};\nuse tokio::sync::{mpsc, Mutex};\nuse tokio::time::{sleep, Duration};\n\nuse crate::common::types::Error;\nuse crate::domain::events::{DomainEvent, UserInputEvent};\nuse crate::domain::interfaces::Subscriber;\n\nconst INPUT_CHANNEL_SIZE: usize = 100;\nconst DISPLAY_REFRESH_MS: u64 = 100;\nconst INPUT_CHECK_MS: u64 = 50;\n\n/// Console-based user interface implementation\n#[derive(Debug)]\npub struct ConsoleUI {\n    topics: Vec<String>,\n    callback: Arc<Mutex<Option<fn(DomainEvent)>>>,\n    tx: Arc<Mutex<Option<mpsc::Sender<DomainEvent>>>>,\n    is_running: Arc<std::sync::atomic::AtomicBool>,\n}\n\nimpl ConsoleUI {\n    /// Creates a new ConsoleUI instance\n    pub fn new(topics: Vec<String>) -> Result<Self, Error> {\n        if topics.is_empty() {\n            return Err(Error::ValidationError(\"Topics list cannot be empty\".to_string()));\n        }\n\n        Ok(ConsoleUI {\n            topics,\n            callback: Arc::new(Mutex::new(None)),\n            tx: Arc::new(Mutex::new(None)),\n            is_running: Arc::new(std::sync::atomic::AtomicBool::new(false)),\n        })\n    }\n\n    /// Handles user input from console\n    async fn handle_input(&self) -> Result<(), Error> {\n        let is_running = Arc::clone(&self.is_running);\n        let tx = Arc::clone(&self.tx);\n\n        tokio::task::spawn_blocking(move || {\n            let stdin = io::stdin();\n            let reader = stdin.lock();\n\n            for line in reader.lines() {\n                 if !is_running.load(std::sync::atomic::Ordering::SeqCst) {\n                    break;\n                }\n\n                if let Ok(input) = line {\n                   let event = match input.trim() {\n                        \"q\" | \"quit\" => Some(DomainEvent::UserInput(UserInputEvent {\n                            action: \"quit\".to_string(),\n                            value: None,\n                        })),\n                        cmd if cmd.starts_with(\"buy \") => {\n                            let parts: Vec<&str> = cmd.split_whitespace().collect();\n                            if parts.len() == 2 {\n                                Some(DomainEvent::UserInput(UserInputEvent {\n                                    action: \"buy\".to_string(),\n                                    value: Some(parts[1].to_string()),\n                                }))\n                            } else {\n                                warn!(\"Invalid buy command format\");\n                                None\n                            }\n                        }\n                        cmd if cmd.starts_with(\"sell \") => {\n                             let parts: Vec<&str> = cmd.split_whitespace().collect();\n                            if parts.len() == 2 {\n                                Some(DomainEvent::UserInput(UserInputEvent {\n                                    action: \"sell\".to_string(),\n                                    value: Some(parts[1].to_string()),\n                                }))\n                             } else {\n                                warn!(\"Invalid sell command format\");\n                                None\n                            }\n                        }\n                        _ => {\n                            warn!(\"Unknown command: {}\", input);\n                            None\n                        }\n                    };\n\n                    if let Some(event) = event {\n                      if let Some(tx) = tx.blocking_lock().as_ref() {\n                          if let Err(e) = tx.blocking_send(event) {\n                              error!(\"Failed to send command: {}\", e);\n                           }\n                        }\n                     }\n                 }\n             }\n         });\n\n        Ok(())\n    }\n\n    /// Processes a single event\n    async fn process_event(&self, event: DomainEvent) -> Result<(), Error> {\n         if let Some(callback) = *self.callback.lock().await {\n             callback(event);\n             Ok(())\n        } else {\n             Err(Error::OperationError(\"Callback not set\".to_string()))\n        }\n    }\n}\n\n#[async_trait]\nimpl Subscriber<DomainEvent> for ConsoleUI {\n    /// Handles incoming events\n    async fn on_event(&self, event: DomainEvent) {\n      if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n          warn!(\"Console UI not running, dropping event\");\n          return;\n      }\n\n      match event {\n          DomainEvent::UserInput(_) => {}, // Don't echo back user input\n          _ => println!(\">> {:?}\", event),\n      }\n    }\n\n    /// Subscribes to events with a callback\n    async fn subscribe(&self, callback: fn(DomainEvent)) -> Result<(), Error> {\n       if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n          return Err(Error::OperationError(\"Cannot subscribe while running\".to_string()));\n      }\n\n      let mut cb = self.callback.lock().await;\n       *cb = Some(callback);\n\n      info!(\"Console UI subscribed with callback\");\n        Ok(())\n    }\n\n    /// Returns the list of topics this subscriber is interested in\n    fn get_source_topics(&self) -> Vec<String> {\n        self.topics.clone()\n    }\n\n    /// Starts the console UI\n    async fn start(&self) -> Result<(), Error> {\n         info!(\"Starting Console UI\");\n\n        if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n           return Err(Error::OperationError(\"Console UI already running\".to_string()));\n         }\n\n         if self.callback.lock().await.is_none() {\n             return Err(Error::OperationError(\"Callback not set\".to_string()));\n        }\n\n         let (tx, mut rx) = mpsc::channel(INPUT_CHANNEL_SIZE);\n        *self.tx.lock().await = Some(tx);\n\n         self.is_running.store(true, std::sync::atomic::Ordering::SeqCst);\n\n         // Start input handler\n        self.handle_input().await?;\n\n        // Start event processing loop\n        let is_running = Arc::clone(&self.is_running);\n\n        tokio::spawn(async move {\n            while is_running.load(std::sync::atomic::Ordering::SeqCst) {\n                if let Ok(event) = rx.try_recv() {\n                  if let Err(e) = self.process_event(event).await {\n                       error!(\"Failed to process event: {}\", e);\n                    }\n                }\n              sleep(Duration::from_millis(DISPLAY_REFRESH_MS)).await;\n             }\n             info!(\"Console UI processing loop stopped\");\n         });\n\n        println!(\"Console UI started. Available commands:\");\n        println!(\"  buy <amount>  - Place a buy order\");\n        println!(\"  sell <amount> - Place a sell order\");\n        println!(\"  q or quit     - Exit the application\");\n\n        Ok(())\n    }\n\n    /// Stops the console UI\n    async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping Console UI\");\n\n       if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Ok(());\n        }\n\n        self.is_running.store(false, std::sync::atomic::Ordering::SeqCst);\n        *self.tx.lock().await = None;\n\n       Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_console_ui_creation() {\n        // Valid topics\n        let topics = vec![\"topic1\".to_string()];\n        assert!(ConsoleUI::new(topics).is_ok());\n\n        // Empty topics list\n        let empty_topics: Vec<String> = vec![];\n        assert!(ConsoleUI::new(empty_topics).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_ui_lifecycle() {\n        let topics = vec![\"test\".to_string()];\n        let ui = ConsoleUI::new(topics).unwrap();\n\n        // Should fail without callback\n         assert!(ui.start().await.is_err());\n\n        // Set callback\n          ui.subscribe(|_| {}).await.unwrap();\n\n        // Start\n        assert!(ui.start().await.is_ok());\n\n        // Should fail to subscribe while running\n       assert!(ui.subscribe(|_| {}).await.is_err());\n\n        // Stop\n        assert!(ui.stop().await.is_ok());\n    }\n}\n",
  "src/ui/logger.rs": "use std::sync::Arc;\nuse async_trait::async_trait;\nuse log::{error, info, warn};\nuse tokio::sync::{mpsc, Mutex};\nuse tokio::time::{sleep, Duration};\n\nuse crate::common::types::Error;\nuse crate::domain::events::DomainEvent;\nuse crate::domain::interfaces::Subscriber;\n\nconst EVENT_CHANNEL_SIZE: usize = 1000;\nconst PROCESSING_INTERVAL_MS: u64 = 100;\n\n/// Event logger implementation\n#[derive(Debug)]\npub struct Logger {\n    topics: Vec<String>,\n    callback: Arc<Mutex<Option<fn(DomainEvent)>>>,\n    tx: Arc<Mutex<Option<mpsc::Sender<DomainEvent>>>>,\n    is_running: Arc<std::sync::atomic::AtomicBool>,\n}\n\nimpl Logger {\n    /// Creates a new Logger instance\n    pub fn new(topics: Vec<String>) -> Result<Self, Error> {\n       if topics.is_empty() {\n            return Err(Error::ValidationError(\"Topics list cannot be empty\".to_string()));\n        }\n\n        for topic in &topics {\n            if topic.is_empty() {\n                return Err(Error::ValidationError(\"Topic cannot be empty\".to_string()));\n            }\n        }\n\n        Ok(Logger {\n            topics,\n            callback: Arc::new(Mutex::new(None)),\n            tx: Arc::new(Mutex::new(None)),\n            is_running: Arc::new(std::sync::atomic::AtomicBool::new(false)),\n        })\n    }\n\n    /// Processes a single event\n    async fn process_event(&self, event: DomainEvent) -> Result<(), Error> {\n        if let Some(callback) = *self.callback.lock().await {\n            callback(event);\n            Ok(())\n        } else {\n            Err(Error::OperationError(\"Callback not set\".to_string()))\n        }\n    }\n\n    /// Formats an event for logging\n    fn format_event(&self, event: &DomainEvent) -> String {\n       match event {\n            DomainEvent::UserInput(e) => format!(\"User Input - Action: {}, Value: {:?}\", e.action, e.value),\n            DomainEvent::OrderStatus(e) => format!(\"Order Status - ID: {:?}, Status: {:?}\", e.order_id, e.status),\n            DomainEvent::TradeSignal(e) => format!(\"Trade Signal - Symbol: {}, Side: {:?}, Size: {}\", e.symbol, e.side, e.size),\n           DomainEvent::PriceUpdate(e) => format!(\"Price Update - Kraken: {:?}, Coinbase: {:?}\", e.kraken_data, e.coinbase_data)\n            // Add other event types as needed\n        }\n    }\n}\n\n#[async_trait]\nimpl Subscriber<DomainEvent> for Logger {\n    /// Handles incoming events\n    async fn on_event(&self, event: DomainEvent) {\n         if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            warn!(\"Logger not running, dropping event\");\n            return;\n        }\n         let formatted = self.format_event(&event);\n        info!(\"Event: {}\", formatted);\n\n        if let Some(tx) = self.tx.lock().await.as_ref() {\n            if let Err(e) = tx.send(event).await {\n                error!(\"Failed to queue event: {}\", e);\n            }\n        }\n    }\n\n    /// Subscribes to events with a callback\n    async fn subscribe(&self, callback: fn(DomainEvent)) -> Result<(), Error> {\n         if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Cannot subscribe while running\".to_string()));\n        }\n\n          let mut cb = self.callback.lock().await;\n          *cb = Some(callback);\n\n        info!(\"Logger subscribed with callback\");\n        Ok(())\n    }\n\n    /// Returns the list of topics this subscriber is interested in\n    fn get_source_topics(&self) -> Vec<String> {\n        self.topics.clone()\n    }\n\n    /// Starts the logger\n    async fn start(&self) -> Result<(), Error> {\n        info!(\"Starting Logger\");\n\n         if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n             return Err(Error::OperationError(\"Logger already running\".to_string()));\n         }\n\n         if self.callback.lock().await.is_none() {\n             return Err(Error::OperationError(\"Callback not set\".to_string()));\n         }\n\n         let (tx, mut rx) = mpsc::channel(EVENT_CHANNEL_SIZE);\n        *self.tx.lock().await = Some(tx);\n\n         self.is_running.store(true, std::sync::atomic::Ordering::SeqCst);\n\n          let is_running = Arc::clone(&self.is_running);\n\n          tokio::spawn(async move {\n             while is_running.load(std::sync::atomic::Ordering::SeqCst) {\n                if let Ok(event) = rx.try_recv() {\n                     if let Err(e) = self.process_event(event).await {\n                         error!(\"Failed to process event: {}\", e);\n                     }\n                  }\n                 sleep(Duration::from_millis(PROCESSING_INTERVAL_MS)).await;\n                }\n            info!(\"Logger processing loop stopped\");\n         });\n\n        Ok(())\n    }\n\n    /// Stops the logger\n    async fn stop(&self) -> Result<(), Error> {\n         info!(\"Stopping Logger\");\n\n        if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Ok(());\n        }\n\n         self.is_running.store(false, std::sync::atomic::Ordering::SeqCst);\n          *self.tx.lock().await = None;\n\n       Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_logger_creation() {\n        // Valid topics\n        let topics = vec![\"topic1\".to_string(), \"topic2\".to_string()];\n        assert!(Logger::new(topics).is_ok());\n\n        // Empty topics list\n        let empty_topics: Vec<String> = vec![];\n        assert!(Logger::new(empty_topics).is_err());\n\n        // Topics with empty string\n        let invalid_topics = vec![\"topic1\".to_string(), \"\".to_string()];\n        assert!(Logger::new(invalid_topics).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_logger_lifecycle() {\n        let topics = vec![\"test\".to_string()];\n        let logger = Logger::new(topics).unwrap();\n\n        // Should fail without callback\n       assert!(logger.start().await.is_err());\n\n        // Set callback\n       logger.subscribe(|_| {}).await.unwrap();\n\n        // Start\n        assert!(logger.start().await.is_ok());\n\n        // Should fail to subscribe while running\n       assert!(logger.subscribe(|_| {}).await.is_err());\n\n        // Stop\n        assert!(logger.stop().await.is_ok());\n    }\n}\n",
  "src/ui/audit.rs": "use std::sync::Arc;\nuse async_trait::async_trait;\nuse log::{error, info, warn};\nuse tokio::sync::{mpsc, Mutex};\nuse tokio::time::{sleep, Duration};\n\nuse crate::common::types::Error;\nuse crate::domain::events::DomainEvent;\nuse crate::domain::interfaces::Subscriber;\n\nconst CHANNEL_SIZE: usize = 1000;\nconst PROCESSING_INTERVAL_MS: u64 = 100;\n\n/// Subscriber that handles audit logging of domain events\n#[derive(Debug)]\npub struct AuditSubscriber {\n    topics: Vec<String>,\n    callback: Arc<Mutex<Option<fn(DomainEvent)>>>,\n    tx: Arc<Mutex<Option<mpsc::Sender<DomainEvent>>>>,\n    is_running: Arc<std::sync::atomic::AtomicBool>,\n}\n\nimpl AuditSubscriber {\n    /// Creates a new AuditSubscriber instance\n    pub fn new(topics: Vec<String>) -> Result<Self, Error> {\n        if topics.is_empty() {\n            return Err(Error::ValidationError(\"Topics list cannot be empty\".to_string()));\n        }\n\n        for topic in &topics {\n            if topic.is_empty() {\n                return Err(Error::ValidationError(\"Topic cannot be empty\".to_string()));\n            }\n        }\n\n        Ok(AuditSubscriber {\n            topics,\n            callback: Arc::new(Mutex::new(None)),\n            tx: Arc::new(Mutex::new(None)),\n            is_running: Arc::new(std::sync::atomic::AtomicBool::new(false)),\n        })\n    }\n\n    /// Processes a single event\n    async fn process_event(&self, event: DomainEvent) -> Result<(), Error> {\n        if let Some(callback) = *self.callback.lock().await {\n            callback(event);\n            Ok(())\n        } else {\n            Err(Error::OperationError(\"Callback not set\".to_string()))\n        }\n    }\n}\n\n#[async_trait]\nimpl Subscriber<DomainEvent> for AuditSubscriber {\n    /// Handles incoming events\n    async fn on_event(&self, event: DomainEvent) {\n         if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            warn!(\"Audit subscriber not running, dropping event\");\n            return;\n        }\n\n        if let Some(tx) = self.tx.lock().await.as_ref() {\n            match tx.send(event.clone()).await {\n                Ok(_) => {\n                    info!(\"Audit received: {:?}\", event);\n                }\n                Err(e) => {\n                    error!(\"Failed to queue event: {}\", e);\n                }\n            }\n        }\n    }\n\n    /// Subscribes to events with a callback\n    async fn subscribe(&self, callback: fn(DomainEvent)) -> Result<(), Error> {\n        if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Cannot subscribe while running\".to_string()));\n        }\n\n         let mut cb = self.callback.lock().await;\n        *cb = Some(callback);\n\n        info!(\"Audit subscribed with callback\");\n        Ok(())\n    }\n\n    /// Returns the list of topics this subscriber is interested in\n    fn get_source_topics(&self) -> Vec<String> {\n        self.topics.clone()\n    }\n\n    /// Starts the audit subscriber\n    async fn start(&self) -> Result<(), Error> {\n        info!(\"Starting audit logger\");\n\n        if self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Err(Error::OperationError(\"Audit subscriber already running\".to_string()));\n        }\n\n         if self.callback.lock().await.is_none() {\n            return Err(Error::OperationError(\"Callback not set\".to_string()));\n        }\n\n\n        let (tx, mut rx) = mpsc::channel(CHANNEL_SIZE);\n        *self.tx.lock().await = Some(tx);\n\n         self.is_running.store(true, std::sync::atomic::Ordering::SeqCst);\n\n          let is_running = Arc::clone(&self.is_running);\n\n        tokio::spawn(async move {\n            while is_running.load(std::sync::atomic::Ordering::SeqCst) {\n                if let Ok(event) = rx.try_recv() {\n                   if let Err(e) = self.process_event(event).await {\n                       error!(\"Failed to process event: {}\", e);\n                   }\n                 }\n              sleep(Duration::from_millis(PROCESSING_INTERVAL_MS)).await;\n             }\n            info!(\"Audit processing loop stopped\");\n          });\n\n        Ok(())\n    }\n\n    /// Stops the audit subscriber\n    async fn stop(&self) -> Result<(), Error> {\n        info!(\"Stopping audit logger\");\n\n        if !self.is_running.load(std::sync::atomic::Ordering::SeqCst) {\n            return Ok(());\n        }\n\n         self.is_running.store(false, std::sync::atomic::Ordering::SeqCst);\n         *self.tx.lock().await = None;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_audit_subscriber_creation() {\n        // Valid topics\n        let topics = vec![\"topic1\".to_string(), \"topic2\".to_string()];\n        assert!(AuditSubscriber::new(topics).is_ok());\n\n        // Empty topics list\n        let empty_topics: Vec<String> = vec![];\n        assert!(AuditSubscriber::new(empty_topics).is_err());\n\n        // Topics with empty string\n        let invalid_topics = vec![\"topic1\".to_string(), \"\".to_string()];\n        assert!(AuditSubscriber::new(invalid_topics).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_subscriber_lifecycle() {\n        let topics = vec![\"test\".to_string()];\n        let subscriber = AuditSubscriber::new(topics).unwrap();\n\n        // Should fail without callback\n        assert!(subscriber.start().await.is_err());\n\n        // Set callback\n      subscriber.subscribe(|_| {}).await.unwrap();\n\n        // Start\n        assert!(subscriber.start().await.is_ok());\n\n        // Should fail to subscribe while running\n       assert!(subscriber.subscribe(|_| {}).await.is_err());\n\n        // Stop\n        assert!(subscriber.stop().await.is_ok());\n    }\n}\n"
}