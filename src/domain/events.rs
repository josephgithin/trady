use serde::{Deserialize, Serialize};
use crate::common::enums::{ExchangeName, StrategyName};

/// Represents the trading side (buy/sell)
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "UPPERCASE")]
pub enum TradeSide {
    Buy,
    Sell,
}

/// Represents the status of an order
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "UPPERCASE")]
pub enum OrderStatus {
    New,
    PartiallyFilled,
    Filled,
    Cancelled,
    Rejected,
}

/// Market data from a specific exchange
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ExchangeData {
    pub exchange: ExchangeName,
    pub pair: String,
    pub price: f64,
}

/// Event containing price updates from multiple exchanges
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PriceUpdateEvent {
    pub kraken_data: Option<ExchangeData>,
    pub coinbase_data: Option<ExchangeData>,
}

/// Trading signal generated by a strategy
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TradeSignalEvent {
    pub symbol: String,
    pub side: TradeSide,
    #[serde(with = "rust_decimal::serde::float")]
    pub size: f64,
    pub strategy: StrategyName,
}

/// Status update for an order
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct OrderStatusEvent {
    pub order_id: String,
    pub status: OrderStatus,
    #[serde(with = "rust_decimal::serde::float")]
    pub filled_size: f64,
    #[serde(with = "rust_decimal::serde::float")]
    pub remaining_size: f64,
    #[serde(with = "rust_decimal::serde::float")]
    pub fill_price: f64,
    pub reason: String,
}

/// Domain events that can occur in the trading system
#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum DomainEvent {
    PriceUpdate(PriceUpdateEvent),
    TradeSignal(TradeSignalEvent),
    OrderStatus(OrderStatusEvent),
}

impl ExchangeData {
    pub fn new(exchange: ExchangeName, pair: String, price: f64) -> Self {
        assert!(price >= 0.0, "Price must be non-negative");
        Self {
            exchange,
            pair,
            price,
        }
    }
}

impl TradeSignalEvent {
    pub fn new(symbol: String, side: TradeSide, size: f64, strategy: StrategyName) -> Self {
        assert!(size > 0.0, "Trade size must be positive");
        Self {
            symbol,
            side,
            size,
            strategy,
        }
    }
}

impl OrderStatusEvent {
    pub fn new(
        order_id: String,
        status: OrderStatus,
        filled_size: f64,
        remaining_size: f64,
        fill_price: f64,
        reason: String,
    ) -> Self {
        assert!(filled_size >= 0.0, "Filled size must be non-negative");
        assert!(remaining_size >= 0.0, "Remaining size must be non-negative");
        assert!(fill_price >= 0.0, "Fill price must be non-negative");
        Self {
            order_id,
            status,
            filled_size,
            remaining_size,
            fill_price,
            reason,
        }
    }
}
